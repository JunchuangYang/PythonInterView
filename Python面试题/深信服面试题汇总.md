## 深信服面试题总结

**这是从牛客网整理的深信服Python工程师的面试题，基本上都是牛客网里一些大佬发的面经。整理一下，便于学习。**

1. 深拷贝和浅拷贝

2. is和==在操作整形数有什么区别

   ```
   事实上Python 为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。而Python 对小整数
   的定义是 [-5, 257)，只有数字在-5到256之间它们的id才会相等，超过了这个范围就不行了，同样的道理，字
   符串对象也有一个类似的缓冲池，超过区间范围内自然不会相等了。 
   
   总的来说，只有数值型和字符串型，并且在通用对象池中的情况下，a is b才为True，否则当a和b是int，str，tuple，list，dict或set型时，a is b均为False。
   ```

3. GIL是什么

4. 线程与协程的区别

5. 垃圾回收机制

6. list和tuple的区别

7. 怎样修改tuple

   ```
   tuple元组的不可变是指元素对象的引用不可变，不能对其再次赋值，但是在其中可变元素对象的引用不被修改前
   提下，仍旧可以对可变元素对象修改
   ```

8. 数组和链表的区别

   ```
   数组
   一、数组的特点
   1.在内存中，数组是一块连续的区域 
   2.数组需要预留空间
   
   在使用前需要提前申请所占内存的大小，这样不知道需要多大的空间，就预先申请可能会浪费内存空间，即数组空间利用率低 
   ps：数组的空间在编译阶段就需要进行确定，所以需要提前给出数组空间的大小（在运行阶段是不允许改变的）
   
   3.在数组起始位置处，插入数据和删除数据效率低。
   
   插入数据时，待插入位置的的元素和它后面的所有元素都需要向后搬移 
   删除数据时，待删除位置后面的所有元素都需要向前搬移
   
   4.随机访问效率很高，时间复杂度可以达到O(1)
   
   因为数组的内存是连续的，想要访问那个元素，直接从数组的首地址处向后偏移就可以访问到了
   
   5.数组开辟的空间，在不够使用的时候需要扩容，扩容的话，就会涉及到需要把旧数组中的所有元素向新数组中搬移 
   6.数组的空间是从栈分配的
   
   二、数组的优点
   随机访问性强，查找速度快，时间复杂度为O(1)
   
   三、数组的缺点
   1.头插和头删的效率低，时间复杂度为O(N) 
   2.空间利用率不高 
   3.内存空间要求高，必须有足够的连续的内存空间 
   4.数组空间的大小固定，不能动态拓展
   
   链表
   一、链表的特点
   1.在内存中，元素的空间可以在任意地方，空间是分散的，不需要连续 
   2.链表中的元素都会两个属性，一个是元素的值，另一个是指针，此指针标记了下一个元素的地址
   
   每一个数据都会保存下一个数据的内存的地址，通过此地址可以找到下一个数据
   
   3.查找数据时效率低,时间复杂度为O(N)
   
   因为链表的空间是分散的，所以不具有随机访问性，如要需要访问某个位置的数据，需要从第一个数据开始找起，依次往后遍历，直到找到待查询的位置，故可能在查找某个元素时，时间复杂度达到O(N)
   
   4.空间不需要提前指定大小，是动态申请的，根据需求动态的申请和删除内存空间，扩展方便，故空间的利用率较高 
   5.任意位置插入元素和删除元素效率较高，时间复杂度为O(1) 
   6.链表的空间是从堆中分配的
   
   二、链表的优点
   1.任意位置插入元素和删除元素的速度快，时间复杂度为O(1) 
   2.内存利用率高，不会浪费内存 
   3.链表的空间大小不固定，可以动态拓展
   
   三、链表的缺点
   随机访问效率低，时间复杂度为0(N)
   ```

9. 堆和栈的区别

   ```
   1、栈区：存放函数的参数值、局部变量等，由编译器自动分配和释放，通常在函数执行完后就释放了，其操作方
   式类似于数据结构中的栈。
   2、堆区：就是通过new、malloc、realloc分配的内存块，编译器不会负责它们的释放工作，需要用程序区释
   放。
   
   堆和栈的区别：
   
   1、堆空间的内存是动态分配的，一般存放对象，并且需要手动释放内存。
   
   2、栈空间的内存是由系统自动分配，一般存放局部变量，比如对象的地址等值，不需要程序员对这块内存进行管
   理，比如，函数中的局部变量的作用范围（生命周期）就是在调完这个函数之后就结束了。这些在系统层面都已经限定住了，程序员只需要在这种约束下进行程序编程就好，根本就没有把这块内存的管理权给到程序员，肯定也就
   不存在让程序员管理一说。
   
   从申请的大小方面讲：
   
   栈空间比较小；
   
   堆空间比较大。
   
   
   从数据存储方面来说：
   
   栈空间中一般存储基本数据类型，对象的地址；
   
   堆空间一般存放对象本身，block的copy等。
   ```

10. 说一下常见排序 哪个排序比较快 时间复杂度是多少

    ```
    在最好情况下，直接插入排序和起泡排序最快；平均情况下，快速排序最快；在最坏情况下，堆排序和归并排序最快。
    ```

11. 进程通信

    ```
    进程间通信方式一共有以下几种:
    
    1,Queue
    
    2.JoinableQueue
    
    3,Pipe
    
    4,共享内存方式(Value,Array)-共享进程方式(Manager)见
    ```

    <https://zhuanlan.zhihu.com/p/42710675>

12. 怎么使用共享内存

    ```python
    Value、Array是通过共享内存的方式共享数据
    
    Manager是通过共享进程的方式共享数据。
    -------------------------------------------------------------------------------   
    进程之间共享数据(数值型-Value)：
    import multiprocessing
     
    def  func(num):
        num.value=10.78  #子进程改变数值的值，主进程跟着改变
     
    if  __name__=="__main__":
        num=multiprocessing.Value("d",10.0) # d表示数值,主进程与子进程共享这个value。
        									#（主进程与子进程都是用的同一个value）
        print(num.value)#10.0
     
        p=multiprocessing.Process(target=func,args=(num,))
        p.start()
        p.join()
     
        print(num.value)#10.78
    -------------------------------------------------------------------------------    
    进程之间共享数据(数组型-Array)：
    import multiprocessing
     
    def  func(num):
        num[2]=9999   #子进程改变数组，主进程跟着改变
     
    if  __name__=="__main__":
        num=multiprocessing.Array("i",[1,2,3,4,5])   #主进程与子进程共享这个数组
        print(num[:])
     
        p=multiprocessing.Process(target=func,args=(num,))
        p.start() 
        p.join()
     
        print(num[:])
    -------------------------------------------------------------------------------   
    进程之间共享数据(dict,list-Manager)：
    import multiprocessing
     
    def func(mydict,mylist):
        mydict["index1"]="aaaaaa"   #子进程改变dict,主进程跟着改变
        mydict["index2"]="bbbbbb"
        mylist.append(11)        #子进程改变List,主进程跟着改变
        mylist.append(22)
        mylist.append(33)
     
    if __name__=="__main__":
        with multiprocessing.Manager() as MG:   #重命名
            mydict=multiprocessing.Manager().dict()   #主进程与子进程共享这个字典
            mylist=multiprocessing.Manager().list(range(5))   #主进程与子进程共享这个List
     
            p=multiprocessing.Process(target=func,args=(mydict,mylist))
            p.start()
            p.join()
     
            print(mylist)
            print(mydict)
    ```

13. http状态码

14. http在哪一层

15. 说一下五层网络协议

16. 网际层有什么协议

    ```
    IP(IPv4 · IPv6) Internet Protocol（网络之间互连的协议）
    ARP : Address Resolution Protocol即地址解析协议，实现通过IP地址得知其物理地址。
    RARP :Reverse Address Resolution Protocol 反向地址转换协议允许局域网的物理机器从网关服务器的 
    	  ARP表或者缓存上请求其 IP 地址。
    ICMP :（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议族的一个子
    	 协议，用于在IP主机、路由器之间传递控制消息。
    ```

17. tcp和udp的区别

18. django怎样做用户登录

19. django加一个网页要改哪些文件

    ```
    url配置URL->view编写视图函数->templates编写模板文件
    ```

20. xss，csrf有什么区别

    ```
    xss：中文名称跨站脚本攻击，通常出现在搜索框、留言板、评论区等地方
    　　分类：反射性、存储型、DOM型
    　　攻击方式：构造恶意链接，诱骗用户点击盗取用户的cookie信息
    　　反射性xss：
    　　　　通常这一类xss危害较低，对网站没有什么严重的影响，具体表现在用户在搜索框输入xss语句返回弹]
    　　　　框，仅出现一次
    　　存储型xss：
    　　　　存储型对网站危害较大，用户插入xss语句后，恶意语句会存入网站数据库中，用户访问过程都会出现弹
    　　　　框
    　　DOM型xss：
    　　　　DOM——文档对象类型
    　　　　利用浏览器的dom解析，更不容易被发现，可以更改页面布局
    　　漏洞危害：xss蠕虫、会话、流量劫持、网站挂马、盗取cookie
    　　防护方法：设置黑名单和白名单、对用户输入进行过滤、入参字符过滤、出参字符转义、设置httponly
    
    CSRF漏洞
    　　csrf漏洞：中文名称跨站请求伪造，攻击者冒充用户身份执行用户操作
    　　漏洞原理：
    　　　　1、用户登录信任网站在未退出的情况下访问攻击者构造的恶意网站
    　　　　2、恶意网站发出访问第三方网站的请求，信任网站收到请求以用户信息访问
    　　　　3、攻击者在用户不知情的情况下冒充用户身份访问成功
    　　检测漏洞：抓取一个请求包，去掉referer字段进行访问，如果访问有效则存在漏洞
    　　危害：盗用用户身份、执行用户操作，修改信息
    　　防护方法：
    　　　　1、设置referer字段；但是并不是所有服务器在任何时候都可以接受referer字段，所以这个方法存在
    　　　　一定的局限性
    　　　　2、设置验证码；在用户操作的过程中设置身份确认的验证码，该方法会很有用，不过验证码频繁的话会
    　　　　影响用户体验
    　　　　3、设置token值，在用户请求中设置一个随机没有规律的token值可以有效的防止攻击者利用漏洞攻击
    　　　　
    区别
    　　从上我们可以总结出：
    　　xss：跨站脚本攻击、诱骗用户点击恶意链接盗取用户cookie进行攻击、不需要用户进行登录、xss除了利用
    　　     cookie还可以篡改网页等
    	csrf：跨站请求伪造、无法获取用户的cookie而是直接冒充用户、需要用户登录后进行操作
    ```

21. sql注入

22. 反转链表

23. 软链接硬链接区别

    ```
     ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接.当我们需要在
    不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固
    定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。
    
    Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard 
    link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特
    殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的
    文件系统。
    
    软链接：
    1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式
    2.软链接可以 跨文件系统 ，硬链接不可以
    3.软链接可以对一个不存在的文件名进行链接
    4.软链接可以对目录进行链接
    
    硬链接:
    1.硬链接，以文件副本的形式存在。但不占用实际空间。
    2.不允许给目录创建硬链接
    3.硬链接只有在同一个文件系统中才能创建
    ```

24. 大端和小端的区别

    ```
    大小端的区别在于数据在内存中的存放字节序不同，大端时一个4字节的数据存放在内存中时，
    高字节存在低地址，低字节存在高地址；小端时高字节存在高地址，低字节存在低地址。
    ```

25. 闭包

26. lamada

27. 迭代器

28. 装饰器

29. Python垃圾回收机制，让讲讲原理

30. udp应用场景

    ```
    #TCP应用场景
    当对网络通信质量有要求时，比如：整个数据要准确无误的传递给对方，这往往对于一些要求可靠的应用，比如HTTP,HTTPS,FTP等传输文件的协议，POP,SMTP等邮件的传输协议。常见使用TCP协议的应用：
    1.浏览器使用的：HHTP
    2.FlashFXP:FTP
    3.Outlook:POP，SMTP
    4.QQ文件传输
    
    UDP 文件传输协议
    对当前网络通讯质量要求不高的时候，要求网络通讯速度尽量的快，这时就使用UDP
    日常生活中常见使用UDP协议：
    1.QQ语音
    2.QQ视频
    3.TFTP
    ————————————————
    原文链接：https://blog.csdn.net/hhthwx/java/article/details/80144582
    ```

31. TCP关闭连接的时候，一般是4次握手，但很多情况下是三次握手，这是什么场景呢

    ```
    我感觉，会只有三次挥手是因为server收到client发来的fin时，本身并没有还未发送的数据，所以就不需要进
    入close _wait状态了，直接ack和fin合并一起发了
    ```

32. 算法题：两个链表，每个节点相加，相加结果如果不是一位数，就拆成多个节点

33. 往1-100里面放1个重复的数字怎么快速找出来这个重复的 

    ```
    思路1：0~100肯定都存在，可以给数组求和然后减去0~100的和，剩下的就是重复的数字；
    ```

34. 编程题： 报数出列，最后一个人是哪个？   

35. linux的进程通信(五种)  

    <https://www.cnblogs.com/zgq0/p/8780893.html>

36. linux僵尸进程怎么解决   

    ```
    如何处理僵尸进程
    
    僵尸进程的产生是因为父进程没有 wait() 子进程。所以如果我们自己写程序的话一定要在父进程中通过 
    wait() 来避免僵尸进程的产生。
    
    当系统中出现了僵尸进程时，我们是无法通过 kill 命令把它清除掉的。但是我们可以杀死它的父进程，让它变
    成孤儿进程，并进一步被系统中管理孤儿进程的进程收养并清理。
    ```
    
    ```
    孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被
    init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
    
    僵尸状态是一个比较特殊的状态，当进程退出父进程（使用wait()系统调用）没有读取到子进程退出的返回代码
    时就会产生僵尸进程。僵尸进程会在以终止状态保持在进程表中，并且会一直等待父进程读取退出状态代码。
    
    僵尸进程与孤儿进程的区别：
    
    孤儿进程是子进程还在运行，而父进程挂了，子进程被init进程收养。
    僵尸进程是父进程还在运行但是子进程挂了，但是父进程却没有使用wait来清理子进程的进程信息，导致子进程虽
    然运行实体已经消失，但是仍然在内核的进程表中占据一条记录，这样长期下去对于系统资源是一个浪费。僵尸进
    程将会导致资源浪费，而孤儿则不会。
    
    那么如何避免僵尸进程呢
    （1）fork两次
    原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程
    （2）通过信号机制
    子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵
    尸进程
    
    原文链接：https://blog.csdn.net/weixin_41050155/java/article/details/81945208
    ```

37. 打开浏览器输入一个网址，发生了啥

38. python的线程同步问题。(详细讲解了GIL的原理)   

39. 又问了进程在实际应用中如何通信的(由15问回答多进程替代多线程引申出来的)   

40. 在一个很长的字符串中找出一个字符第一次出现的位置

    `字典，hash`

41. 二叉平衡树的查找时间复杂度  log2n。

42. is和==

43. 字符串去掉首尾两个字符：` str[1:-1]`

44. 切片字符串逆序:`str1[::-1]`

45. 两个列表去掉相同的元素

46. 列表和元组的区别

47. 一个数组找出第一个出现一次的元素

48. classmethod 和 staticmethod

49. 快排和冒泡的时间复杂度，稳定性:`快排：O(nlogn)，不稳定 冒泡：O（n^2）,稳定`

50. 复杂度为O(n)的排序算法`桶排序、基数排序、计数排序`<https://www.jianshu.com/p/7feeebc54d92>

51. ·`十六进制的正则表达式`

52. 数组链表的区别

53. 链表判环：`快慢指针`<https://www.cnblogs.com/qingyunzong/p/9143321.html>

54. 进程通信

55. 计网七层，端口在哪一层加：`传输层`

56. mysql端口号：`3306`

57. MySQL引擎:`Myisam 和Innodb `

58. 为什么不能所有字段都加索引

    ```
    每个索引必须在行被更新、插入或删除时随时更新。因此，索引越多，写操作的性能就越慢。
    
    而且，每个索引都占用更多的磁盘空间和内存空间(当调用时)，因此它也可能减缓读取操作(对于大型表)。
    ```

59. python内存管理？` **Python的内存管理机制：**引用计数、垃圾回收、内存池机制`

    ```
    1、引用计数	
    	python内部使用引用计数，来保持追踪内存中的对象，Python内部记录了对象有多少个引用，即引用计
    	数，当对象被创建时就创建了一个引用计数，当对象不再需要时，这个对象的引用计数为0时，它被垃圾回
    	收。
    
    2、垃圾回收
        1、当内存中有不再使用的部分时，垃圾收集器就会把他们清理掉。它会去检查那些引用计数为0的对象，然
        后清除其在内存的空间。当然除了引用计数为0的会被清除，还有一种情况也会被垃圾收集器清掉：当两个
        对象相互引用时，他们本身其他的引用已经为0了。
    
        2、垃圾回收机制还有一个循环垃圾回收器, 确保释放循环引用对象(a引用b, b引用a, 导致其引用计数永
        远不为0)。
        
    为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。
    
    3、内存池机制
    
        Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。
    
        Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的 malloc。
        
    Python的内存池机制以金字塔行，-1，-2层主要有操作系统进行操作，
    
    　　第0层是C中的malloc，free等内存分配和释放函数进行操作；
    
    　　第1层和第2层是内存池，有Python的接口函数PyMem_Malloc函数实现，当对象小于256K时有该层直接分配
    　　内存；
    
    　　第3层是最上层，也就是我们对Python对象的直接操作；
    ```

60. 循环引用的处理:`标记清除、分代回收`

61. 协程是什么 ，协程的原理 

62. Linux的Top命令：`top命令命令用于实时监测系统资源使用状况，包含，进程、cpu，内存等`

63. Fork的返回值

    ```
    fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：
        1）在父进程中，fork返回新创建子进程的进程ID；
        2）在子进程中，fork返回0；
        3）如果出现错误，fork返回一个负值；
    ```

64. Linux的文件类型？

    ```
    文件属性	文件类型
    -	常规文件，即file
    d	目录文件
    b	block device 即块设备文件，如硬盘;支持以block为单位进行随机访问
    c	character device 即字符设备文件，如键盘支持以character为单位进行线性访问
    l	symbolic link 即符号链接文件，又称软链接文件
    p	pipe 即命名管道文件
    s	socket 即套接字文件，用于实现两个进程进行通信
    ```

65. 说一下python中的数据结构。可变不可变？

66. 知道GIL吗？为什么需要GIL呢？GIL为什么一次只允许解释执行1个线程呢？ 

    ```
    由于Python是需要经过解释器编译成字节码后再执行的，所以有例如CPython、PyPy等解释器，提到GIL时，一般指CPython，CPython设置GIL的主要原因是为了保证不让多个线程同时执行同一条字节码，这就避免了可能多个线程同时对某个对象进行操作。
    
    
    ```

67. 知道多线程，多进程吗？介绍一下怎样创建多线程，多进程？请问与java的区别是？ 

    ```
    Java
    Java编写的程序都运行在在Java虚拟机（JVM）中，每用java命令启动一个java应用程序，就会启动
    一个JVM进程。在同一个JVM进程中，有且只有一个进程，就是它自己。在这个JVM环境中，所有程序代
    码的运行都是以线程来运行的。JVM找到程序程序的入口点main()，然后运行main()方法，这样就产
    生了一个线程，这个线程称之为主线程。当main方法结束后，主线程运行完成。JVM进程也随即退出。
    
    Python
    
    但是听闻Python的多线程实际上并不能真正利用多核，所以如果使用多线程实际上还是在一个核上做并
    发处理。不过，如果使用多进程就可以真正利用多核，因为各进程之间是相互独立的，不共享资源，可
    以在不同的核上执行不同的进程，达到并行的效果。
    ```

68. tcp3次握手？第三次握手失败后会怎样？ <https://yuanrengu.com/2020/77eef79f.html>

69. 数据结构都知道哪些？说一下平衡二叉树。怎么构建平衡二叉树呢？  

    ```
    数组、栈、队列、链表、树、散列表、堆、图。
    
    平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是
    一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
    
    旋转
    ```

70. python装饰器知道吗？装饰器的原理是什么？本质是？闭包？ 

    ```
    装饰器的本质是函数，主要用来装饰其他函数，也就是为其他函数添加附加功能
    ```

71. Mysql与MongoDB的区别是？ 

72. python中的socket? 

73. hash算法知道吗?介绍一下你知道的hash算法。hash冲突知道吗？怎么解决hash冲突呢？ 

    ```
    1.开放地址法：线性探测再散列、平方探测再散列
    2.链地址法
    3.再哈希
    4.建立公共溢出区
    ```

74. poll,select,epoll. （I/O多路复用，不会）

75. linux指令知道哪些？（这个我说我学过一些，但是背不下来，看笔记的话能够使用） 

76. 操作系统了解吗? 

77. **python的内存处理机制有哪些？分别介绍一下。** 

78. 说一说你知道的时间复杂度为O(nlogn)的算法。以快排为例，具体解释一下为什么它的时间复杂度是O(nlogn)呢？ 

    ```
    快排是从所给的要排序的数中先随机抽出一个数(一般选择第一个数作为基数)。然后遍历输入的数(将
    每个数和抽出的数比较，比它小的放左边，比大它的放右边)～～～该过程的时间复杂度为n(第一步),
    
    然后递归的完成上述操作～～该递归的操作时间复杂度是logn(与遍历二叉树的操作类似)(第二步)～
    
    ～～所以第一步和第二步合起来。最终快排的时间复杂度是nlogn(它是不稳定算法)
    
    归并排序：从递归的角度来分析的话：
    第一步：遍历所有的数，两两比较进行排序，这就完成了一趟操作。它的时间复杂度为n..
    
    第二步：递归完成上述操作～～它的时间复杂度为logn～～～～～～～～～
    所以总的就是nlogn它是稳定的算法
    
    从非递归的角度：合并每个子问题，得到原问题的解。它的时间复杂度是n(外层循环)～～～～～
    每个子问题求解需要logn的时间复杂度(内层循环).........
    所以最终它的时间复杂度还是nlogn
    
    原文链接：https://blog.csdn.net/qq_41063141/java/article/details/90744948
    ```

79. 类似快排的这些算法思想都属于什么算法？（分治算法）

    请你说一说这一类算法的时间复杂度有什么规律？快排是分成两组，是否可以分为更多组呢？为什

    么？

80. 快排快，还是归并排序快？

    ```
    按照理论上分析，快排平均时间复杂度O（nlogn）,最坏为n^2,归并平均和最坏均为nlogn。
    理论上应该是归并快才对，但是有好多人测试很大规模数据的情况下快排比归并快。
    可能的原因，归并有空间开销，有数组复制合并的操作，快排属于原地排序，在数据规模大的情况下，
    差距就出来了
    
    原文链接：https://blog.csdn.net/weixin_40759186/java/article/details/84975541
    ```

81. 图你了解吗？说一说图的实现/表示（数组加链表，二维数组），说一下二者的区别？每一种更适合用在哪一种情况下？ 

    ```
    　数组应用场景：数据比较少；经常做的运算是按序号访问数据元素；数组更容易实现，任何高级语言
    都支持；构建的线性表较稳定。
    
    　　链表应用场景：对线性表的长度或者规模难以估计；频繁做插入删除操作；构建动态性比较强的线
    　性表。
    ```

82. 说一下找图中两个点的最短路径的方法？具体讲一下。

    ```
    dijkstra和Floyd算法
    
    dijkstra算法介绍：即迪杰斯特拉算法，是从一个顶点到其余各顶点的最短路径算法，解决的是有向
    图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止，
    是一种广度优先的搜索方法。
    ```

83. tcp协议和ip协议，讲一下具体内容。在3次握手4次挥手之外，tcp协议还怎么保证连接？（我答的

    是挥手每次失败会怎么样，握手每次失败会怎么样） 

    ```
    传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节
    流的传输层通信协议.
    
    IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的
    是，IP提供不可靠、无连接的数据传送，赖其他层的协议进行差错控制。不可靠指的是IP数据报不保证
    能成功的到达目的地，如果出现错误则选择丢弃该数据，然后发送ICMP消息报给信源端。无连接指的是
    IP不提供任何后续数据报的状态信息，每个数据报处理都是独立的。如果一个信源发送了连续的两个数
    据报，每个数据报选择独立的路由，两个数据可能不同时到达。
    
    TCP第三次握手失败怎么办，即最后一次握手失败:
    --当失败时服务器并不会重传ack报文，而是直接发送RTS报文段，进入CLOSED状态。这样做的目的是
      为了防止SYN洪泛攻击。
      
    3，如果已经建立了连接，但是客户端突然出现故障了怎么办？
    TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服
    务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收
    到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探
    测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
    ```

84. 你知道io复用机制吗？ (NO)

85. python里面的数据类型有哪些，哪些是可变数据类型，哪些是不可变数据类型。

86. 给定一张表，写出SQL语句，字段有id,name,subject,grade。求出总分大于300分的学生的名单，求出没有不及格成绩的学生名单。 

    ```mysql
    select name from table group by name having sum(score)>240
    
    select name from table group by name having min(score)>59
    ```

87. 问了http的报文结构，问我知道有哪些报文头。get和post的区别是什么。

    <https://www.cnblogs.com/chenguangliang/p/6708592.html> 

88. 给定一个序列，问冒泡排序和快速排序的基本流程，写出每次排列的结果。

89. 如果一个人在公交车站台一分钟内能等到公交车的概率为p，那么这个人在三分钟里能等到这辆公交车的概率为多少？(从反面去思考）

    1-(1-p)*(1-p)*(1-p)

90. 4个人过桥的时间分别为1分钟，3分钟，7分钟，9分钟。只有一个手电筒，每次只能两个人过桥，过桥时间以两个人中最慢的那个人过桥时间为准。问这四个人全部过桥最少需要多少时间。

    ```
    不知道是不是正解：
    1和3过，1回来，4分钟
    7和9过，3回来，12分钟
    1和3过，3分钟
    共计19分钟
    ```

91. GIL是什么？python里常用的数据类型有哪些？深拷贝和浅拷贝的区别？python里装饰器的作用，怎么去构造一个装饰器？字符串拼接直接用+会产生什么问题，怎么去优化？python函数中如果传入确定的参数，那么python在运行这个程序的时候他是在什么时期被确定下来的？如果确定的参数是一个列表，那么后面可能会遇到什么坑？python中is和==有什么区别？

    ```
    字符串拼接直接用+会产生什么问题，怎么去优化？
    
    由于变量str是不变对象，每次遍历，Python都会生成新的str对象来存储新的字符串，所以num越
    大，创建的str对象就越多，内存消耗约大，速度越慢，性能越差。 如果要改变上面的问题，可以变字
    符串拼接为join联合的方式
    
    python函数中如果传入确定的参数，那么python在运行这个程序的时候他是在什么时期被确定下来
    的？  定义参数的时候
    详见：https://www.cnblogs.com/gpd-Amos/p/8998059.html
    ```

92. python中is和==的区别 

93. python操作文件需要考虑哪些因素（`打开方式，编码格式,异常处理，要正常关闭，接收缓冲区的大小`） 

94. 多个进程都要读写一个文件，怎样避免脏读。 

    `Python multiprocessing 多进程之间相互协调的方式有如下几种: Lock:锁,Queue:队列, Semaphore:信号量 ,Event:事件，Pipe:管道 。`

95. python字符串拼接哪种方式最好（+=和join的区别） 

96.  mysql性能调优（没怎么回答上来） 

    ```
    1、避免 SELECT *。从数据库里读出越多的数据，那么查询就会变得越慢。
    2、单条查询最后增加 LIMIT 1，停止全表扫描。
    3、尽量把字段设置为NOT NULL
    	 在可能的情况下，尽量把字段设置为NOT NULL,这样在将来执行查询的时候，数据库不用去比较NULL值。
    5、充分使用索引
    6、避免随机取记录
    	SELECT * FROM t1 WHERE 1=1 ORDER BY RAND() LIMIT 4;
    	MySQL不支持函数索引，会导致全表扫描
    7、分析查询日志和慢查询日志
    ```

97.   mysql执行查询100w的数据，怎样优化 

    <https://www.cnblogs.com/mengxz0626/p/5086055.html>

98.   你链表主要用在哪里（我回答的算法题的应用，忘记说之前用c开发小游戏的时候用到过） 

99.   什么是僵尸进程 

100.   怎样用python的多进程来解决僵尸进程（分开讲还了解，这两个和在一起就蒙了） 

     ```
     方法一：信号方式：（转自别处）问题解决了，是没有处理信号，如果子进程退出时，主进程不需要处理资源释放
     问题，就可以在主进程程序中加入一句import signal 
     signal.signal(signal.SIGCHLD,signal.SIG_IGN)
     
     方法二：wait方式：子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候
     结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的
     终止状态。
     
     os.waitpid(forkid,0) 主进程会阻塞等待子进程结束
     
     方法三：fork两次
     
     
     
     若子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进
     程。
     
     有什么坏处?　如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进
     程的危害，应当避免。
     
     僵尸进程的避免:
     1、父进程通过os.wait()和os.waitpid()等函数等待子进程结束，这会导致父进程挂起。
     2、如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler，因为子进程结束后， 父进程会收到该信
     号，可以在handler中调用wait回收。
     3、如果父进程不关心子进程什么时候结束，那么可以用signal（SIGCHLD,SIG_IGN） 通知内核，自己对子进
     程的结束不感兴趣，那么子进程结束后，内核会回收， 并不再给父进程发送信号。
     4、还有一些技巧，就是fork两次，父进程fork一个子进程，然后继续工作，子进程fork一个孙进程后退出，那
     么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收 还要自己做。
     
     子进程变成僵尸进程，是因为父进程先执行完，没有替子进程收尸。而wait()并不是用来收尸的，只是防止父进
     程先于子进程退出；如果父进程先退出，会使子进程成为僵尸进程，这时候子进程的收尸就由1号init进程来回
     收。
     ```

101.   用到过什么调试python程序的方法（pdb，Django的debug） 

102.   了解过哪些web攻击（csrf，xss，SYN，DDos） 

     ```
     SYN洪泛攻击:攻击者发送许多数据包，但不向服务器发送“ACK”。因此，连接半开，吞下服务器资源。由于阻止服务攻击，合法用户尝试连接到服务器但被拒绝。
     
     DDoS 攻击;全称是 Distributed Denial of Service，翻译成中文就是分布式拒绝服务。一般来说是指攻
     击者利用“肉鸡”对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务。
     在线游戏、互联网金融等领域是 DDoS 攻击的高发行业。
     ```

103.   你的网站应用出现500错误该怎么排查 ?`该网站有程序错误。`

104.   计算机网络（五层模型，每一层的作用）

     <https://blog.csdn.net/susanhc/article/details/97026765>

     ```  
      物理层:负责把两台计算机连起来，主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。
      
      数据链路层:工作在物理层之上，负责给这些0，1制定传送的规则，然后另一方再按照相应的规则来进行解读。
      		  (以太网协议、mac地址、广播与ARP协议)
      
      网络层：作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络，这套地址就叫		  做“网络地址”，简称网址。
      	   ARP协议和RARP协议是网络层的协议，但是它工作的内容是链路层的。ARP是在仅知道主机的IP地址时确
      	   定其物理地址的协议。
      
      传输层：“传输层”的功能，就是建立“端口到端口”的通信，相比之下，“网络层”
     		的功能是建立“主机到主机”的通信，只要确定主机和端口，我们就能实现程序之间的交流。
      
      应用层：应用层收到传输层的数据，接下来就要进行解读，由于互联网是开放架构，数据来源五花八门，必须事
      	    先规定好格式，否则根本无法解读。“应用层”的作用，就是规定应用程序的数据格式。
     ```

105.   传输层（tcp，udp都讲一遍） 

106. python列表，元祖，字典的底层实现 

     ```
     列表：Python中的列表是由对其它对象的引用组成的连续数组。指向这个数组的指针及其长度被保存在一个列表
     	头结构中。这意味着，每次添加或删除一个元素时，由引用组成的数组需要该标大小（重新分配）。
     
     元祖：tuple 和 list 相似，本质也是一个数组，但是空间大小固定。
     
     字典：在Python中，字典是通过散列表或说哈希表实现的。字典也被称为关联数组，还称为哈希数组等。也就是
          说，字典也是一个数组，但数组的索引是键经过哈希函数处理后得到的散列值。
          
          常见的哈希碰撞解决方法：
          	1 开放寻址法（open addressing）
          	2 再哈希法
          	3 链地址法
          	4 公共溢出区
          	5 装填因子α
     ```

     <http://c.biancheng.net/view/5360.html>

107. python装饰器的底层实现和作用（函数闭包） 

     `Python中的装饰器是通过利用了函数特性的闭包实现的`

108. 你在实际项目中哪里用到过装饰器 

109. http的特点 

     ```
     HTTP 是一个属于应用层的面向对象的协议，
     HTTP 协议一共有五大特点：1、支持客户/服务器模式；2、简单快速；3、灵活；4、无连接；5、无状态。
     
     无连接:无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开	    连接。采用这种方式可以节省传输时间。
     
     无状态:指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之
           后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。
     ```

     <https://www.cnblogs.com/xuxinstyle/p/9813654.html>

110. http的状态码以及具体意思（200,301,302,304,400,401,402,403,404,500,503,504） 

111. cookie和session的区别（延伸token） 

     <https://www.cnblogs.com/moyand/p/9047978.html>

     ```
     Cookie
     cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储
     功能。
     cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同
     一网站时会把该
     cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使
     用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。
     
     
     Session
     session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四
     呢？对方肯定有某种特征（长相等）表明他就是张三。
     session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端
     分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求
     来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 
     cookie 的方式。
     
     服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储
     方式相对cookie来说更安全，
     可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session
     会丢失。
     
     Token
     在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，tokens 是多用户下处理认证的最佳方式。
     以下几点特性会让你在程序中使用基于Token的身份验证
     1.无状态、可扩展
     2.支持移动设备
     3.跨程序调用
     
     基于Token的验证原理
     基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。
     这种概念解决了在服务端存储信息时的许多问题
     　　NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。
     基于Token的身份验证的过程如下:
     1.用户通过用户名和密码发送请求。
     2.程序验证。
     3.程序返回一个签名的token 给客户端。
     4.客户端储存token,并且每次用于每次发送请求。
     5.服务端验证token并返回数据。
     
     实现思路：
     1.用户登录校验，校验成功后就返回Token给客户端。
     2.客户端收到数据后保存在客户端
     3.客户端每次访问API是携带Token到服务器端。
     4.服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码
     ```

112. 网站的登录怎么做的 

113. 网页重定向具体是怎么实现的 

114. http请求和响应由哪些部分组成 

     详见：<https://www.cnblogs.com/dashu123/p/11564006.html>

     ```
     下面先来说说请求的构成：
     
     1）请求方法URI协议/版本 
     
     2）请求头(Request Header) 
     
     3）请求正文
     
     响应的构成HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成：
     
     1）状态行
     
     2）响应头
     
     3）响应正文
     ```

115. csrf跨域请求是怎样实现的（没回答上来） 

     ```
     简单来说，CSRF必须经过两个步骤：
     
     1、用户访问可信任站点A，并产生了相关的cookie；
     
     2、用户在访问A站点时没有退出，同时访问了危险站点B；
     
     大家同时访问多个网站是很正常的事情，所以也很容易遭到CSRF的攻击。
     ```

116. mysql索引以及具体实现（B+树） 

     [MySQL索引的数据结构以及算法原理](<https://blog.csdn.net/qq_36381855/article/details/80011876>)

117. 为什么innodb要用B+为索引（我回答的是B+树比较B树的优点） 

     ```
     一 B-tree
     B树也称B-tree,它是一棵多路平衡查找树。
     
     描述一颗B树时需要指定它的阶数，阶数表示了一个节点最多有多少个孩子节点，一般用字母 m 表示阶数。
     
     1、每个节点最多有 m 个子树，以及最多 m-1 个关键字）。
     2、根节点最少有 2 个子树，可以只有 1 个关键字。
     3、非根节点至少有 m/2 个关键字。
     4、每个节点中的关键字都升序排列。
     5、所有叶子节点都位于同一层。
     6、每个节点都存有索引和数据，也就是对应的 key 和 value。
     所以，根节点的关键字数量范围：1 <= k <= m-1，非根节点的关键字数量范围：m/2 <= k <= m-1。
     
     二 介绍 B+tree 的数据结构？
     B+tree 是在 B-tree 的基础上，新增加了两个要求：
     
     1、B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点只存储
        索引，数据都存储在叶子节点。
     2、B+树叶子节点保存了父节点的所有关键字和关键字记录的指针，每个叶子节点的关键字从小到大链接，构成一
       个链表结构。
     
     B+tree 相比 B-tree 的优势:
     1、单一节点存储的元素更多，使得查询的 I/O 次数更少，所以也就使得它更适合做为数据库MySQL的底层数据
        结构了。
     2、所有的查询都要查找到叶子节点，查询性能是稳定的，而 B-tree，每个节点都可以查找到数据，所以不稳
        定。
     3、B+tree，所有的叶子节点形成了一个有序链表，更加便于查找。
     
     原文链接：https://blog.csdn.net/mahaibin97/java/article/details/101546185
     ```

118. 哪些数据结构可以用来做索引？有什么优缺点？（数组，链表，哈希表，二叉树，B树，B+树） 

119. linux查看端口进程的方法 

     ```
     linux如何查看端口被哪个进程占用的方法：
     
     1、lsof -i:端口号   (list open files)
     
     2、netstat -tunlp|grep 端口号
     ```

     <https://www.cnblogs.com/fps2tao/p/10042553.html>

120. linux进程间通信有哪些方法?

     ```
     进程间通信常见方式如下：
         管道
         FIFO(命名管道)
         消息队列
         信号量
         共享内存
         套接字（Socket）
     ```

121. 你怎样获取到访问用户的真实IP地址（HTTP_ADDR和HTTP_X_FORWaRDED_FOR） 

     ```python
     目前比较流行的获取访问用户的IP方式是使用request.META属性，获取键
     值“HTTP_X_FORWARDED_FOR”或“REMOTE_ADDR来获取IP地址信息
     
     ’REMOTE_ADDR’:是远端IP，默认来自tcp 连接是，客户端的Ip。可以说，它最准确，确定是，只会得到直接连
     		      服务器客户端IP。如果对方通过代理服务器上网，就发现。获取到的是代理服务器IP了。
     ’HTTP_X_FORWARDED_FOR’:’HTTP_CLIENT_IP’ 为了能在大型网络中，获取到最原始用户IP，或者代理IP
                             地址。对HTTp协议进行扩展。定义了实体头。
     
     def get_client_ip(request):
         x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
         if x_forwarded_for:
             ip = x_forwarded_for.split(',')[0]
         else:
             ip = request.META.get('REMOTE_ADDR')
         return ip
     ————————————————
     ```

     https://blog.csdn.net/bibinGee/java/article/details/103723758

122. 一个校园网，所有学生都是通过这个网连接外网，你获取的是真实IP还是校园网的地址？具体用到了哪些技术？（网络层基础有些薄弱,没怎么回答出来） 

123. 谈谈你对REST API的理解 

124. 什么是序列化，有什么用 

     ```
     1、什么是序列化与反序列化？
     # 我们把对象（或变量）从内存变成可存储或可传输的过程称之为序列化，在python中被称为picking；
     
     # 自定义的类的实例如何保存在一个文件中？如何从文件中读取数据，并让他们在内存中再次恢复成自己对应的类的实例？
     
     # 按照某种规则，把内存中的数据保存到文件中，文件是一个字节序列，所以必须要把内存数据转换成为字节序列，输出到文件，这就是序列化；反之，从文件的字节恢复到内存，就是反序列化；
     
     2、为什么要序列化？
     # 持久化保持状态；
     
     # 跨平台的数据交互；
     
     3、pickle
     # pickle模块是python专用的持久化模块，可以持久化包括自定义类在内的各种数据；只能在python程序之间进行数据交换；
     
     # 方法：
     
     dumps 　　将对象序列化成bytes对象；
     dump 　　 对象序列化到文件对象，就是存入文件；
     loads　　  从bytes对象反序列化；
     load　　    对象反序列化，从文件读取数据；
     # 注意：在使用dump()序列化时候，打开文件必须要以wb模式，使用load()反序列化，打开文件必须以rb模式；
     ```

125. 数据库外键和主键的区别，外键有什么用，实际项目中你是怎么应用的 

     ```
     主键、外键和索引的区别？
     主键:
     	定义：唯一标识一条记录，不能有重复的，不能为空
     	作用：用来保证数据完整性
     	个数：主键只能有一个
     	
     外键:
     	定义：表的外键是另一表的主键, 外键可以有重复的, 可以是空值
     	作用：用来和其他表建立联系用的
     	个数：	一个表可以有多个外键
     	
     索引:
     	定义：该字段没有重复值，但可以有一个空值
     	作用：是提高查询排序的速度
     	个数：一个表可以有多个惟一索引	
     	
     	聚集索引和非聚集索引的区别？
     		聚集索引一定是唯一索引。但唯一索引不一定是聚集索引。  
     		聚集索引，在索引页里直接存放数据，
     		而非聚集索引在索引页里存放的是索引，这些索引指向专门的数据页的数据。
     ```

126. 部署过redis集群吗？（没有） 

127. 你了解哪些设计模式（单例，工厂，装饰器，状态机） 

128. TCP滑动窗口的作用 

     ```
     作用：
         1. 提供TCP可靠性：对发送的数据进行确认
         2. 流量控制：窗口大小随链路变化
     ```

     [TCP面试题之滑动窗口原理](https://www.cnblogs.com/hujinshui/p/10472671.html)