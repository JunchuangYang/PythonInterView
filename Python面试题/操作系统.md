## **操作系统**

来源：<https://blog.csdn.net/a934079371/article/details/101731252>

**1、简单说下你对并发和并行的理解？**

1. 并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生；

2. 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件；

**2、同步、异步、阻塞、非阻塞的概念**

**同步**：当一个同步调用发出后，调用者要一直等待返回结果。通知后，才能进行后续的执行。

**异步**：当一个异步过程调用发出后，调用者不能立刻得到返回结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。

**阻塞**：是指调用结果返回前，当前线程会被挂起，即阻塞。

**非阻塞**：是指即使调用结果没返回，也不会阻塞当前线程。

**3、进程和线程的基本概念**

进程：进程是系统进行资源分配和调度的一个独立单位，是系统中的并发执行的单位。

线程：线程是进程的一个实体，也是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位，有时又被称为轻权进程或轻量级进程。

**4、进程与线程的区别？**

1. 进程是资源分配的最小单位，而线程是 CPU 调度的最小单位；

2. 创建进程或撤销进程，系统都要为之分配或回收资源，操作系统开销远大于创建或撤销线程时的开销；

3. 不同进程地址空间相互独立，同一进程内的线程共享同一地址空间。一个进程的线程在另一个进程内是不可见的；

4. 进程间不会相互影响，而一个线程挂掉将可能导致整个进程挂掉；

**5、为什么有了进程，还要有线程呢？**

 进程可以使多个程序并发执行，以提高资源的利用率和系统的吞吐量，但是其带来了一些缺点：

1. 进程在同一时间只能干一件事情；

2. **进程在执行的过程中如果阻塞，整个进程就会被挂起**，即使进程中有些工作不依赖与等待的资源，仍然不会执行。

基于以上的缺点，操作系统引入了比进程粒度更小的线程，**作为并发执行的基本单位**，从而减少程序在并发执行时所付出的时间和空间开销，提高并发性能。

**6、进程的状态转换**

进程包括三种状态：就绪态、运行态和阻塞态。

![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/I47RwB1Z6MwBgUOwfFHscBdJsMMn19D6nRhxJtkFOnMCjG62C5rIMSibRAvNJia64LTLmic3Qb57Kzu2E4Q1ibibNUw/640?wx_fmt=png)

1. 就绪 —> 执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；

2. 执行 —> 阻塞：正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等； 

3. 阻塞 —> 就绪：处于阻塞状态的进程，在其等待的事件已经发生**，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态**，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；

4. 执行 —> 就绪：正在执行的进程，**因时间片用完而被暂停执行**，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。

**7、进程间的通信方式有哪些？**

进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。IPC 的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams 等。其中 Socket 和 Streams 支持不同主机上的两个进程 IPC。

- **管道**

1. 它是半双工的，具有固定的读端和写端；

2. **它只能用于父子进程或者兄弟进程之间的进程的通信**；

3. 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read、write  等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

- **命名管道**

1. FIFO 可以**在无关的进程之间交换数据**，与无名管道不同；

2. FIFO 有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。

- **消息队列**

1. 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符 ID 来标识；

2. 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级；

3. 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除；

4. 消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。

- **信号量**

1. 信号量（semaphore）是一个计数器。用于实现进程间的互斥与同步，而不是用于存储进程间通信数据；

2. 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存；

3. **信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作**；

4. 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数；

5. 支持信号量组。

- **共享内存**

1. 共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区；

2. 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。

**线程之间的通信**:[python 实现线程之间的通信](https://www.cnblogs.com/shenh/p/10825656.html)

1. threading.Lock()

   - 如果多个线程对某一资源同时进行修改，可能会存在不可预知的情况。为了修改数据的正确性，需要把这个资源锁住，只允许线程依次排队进去获取这个资源。当线程A操作完后，释放锁，线程B才能进入。

2. threading.RLock()

   - 用法和 threading Lock() 一致，区别是 threading.Rlock() 允许多次锁资源，acquire() 和 release() 必须成对出现，也就是说加了几把锁就得释放几把锁。

3. threading.Condition()

   - threading.Condition() 可以理解为更加高级的锁，比 Lock 和 Rlock 的用法更高级，能处理一些复杂的线程同步问题。threading.Condition() 创建一把资源锁（默认是Rlock），提供 acquire() 和 release() 方法，用法和 Rlock 一致。此外 Condition 还提供 wait()、Notify() 和 NotifyAll() 方法。

     - **wait()：**线程挂起，直到收到一个 Notify() 通知或者超时（可选参数），wait() 必须在线程得到 Rlock 后才能使用。

     - **Notify() ：**在线程挂起的时候，发送一个通知，让 wait() 等待线程继续运行，Notify() 也必须在线程得到 Rlock 后才能使用。 Notify(n=1)，最多唤醒 n 个线程。

     - **NotifyAll()** ：在线程挂起的时候，发送通知，让所有 wait() 阻塞的线程都继续运行。

4. threading.Event()

   -  threading.Event() 原理是在线程中立了一个 Flag ，默认值是 False ，当一个或多个线程遇到 event.wait() 方法时阻塞，直到 Flag 值 变为 True 。threading.Event() 通常用来实现线程之间的通信，使一个线程等待其他线程的通知 ，把 Event 传递到线程对象中。

     - event.wait() ：阻塞线程，直到 Flag 值变为 True

     - event.set() ：设置 Flag 值为 True

     - event.clear() ：修改 Flag 值为 False

     - event.isSet() :  仅当 Flag 值为 True 时返回

**8、进程的调度算法有哪些？**

调度算法是指：根据系统的资源分配策略所规定的资源分配算法。常用的调度算法有：先来先服务调度算法、时间片轮转调度法、短作业优先调度算法、最短剩余时间优先、高响应比优先调度算法、优先级调度算法等等。

- **先来先服务调度算法**

先来先服务调度算法是一种最简单的调度算法，也称为**先进先出或严格排队**方案。当每个进程就绪后，它加入就绪队列。当前正运行的进程停止执行，选择在就绪队列中存在时间最长的进程运行。该算法既可以用于作业调度，也可以用于进程调度。先来先去服务比较适合于常作业（进程），而不利于段作业（进程）。

- **时间片轮转调度算法**
- 

时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列**中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片**。

- **短作业优先调度算法**

短作业优先调度算法是指对短作业优先调度的算法，**从后备队列中选择一个或若干个估计运行时间最短的作业**，将它们调入内存运行。 短作业优先调度算法是一个非抢占策略，他的原则是下一次选择预计处理时间最短的进程，因此短进程将会越过长作业，跳至队列头。

- **最短剩余时间优先调度算法**

最短剩余时间是针对最短进程优先增加了抢占机制的版本。在这种情况下，进程调度总是选择预期剩余时间最短的进程。当一个进程加入到就绪队列时，他可能比当前运行的进程具有更短的剩余时间，因此只要新进程就绪，调度程序就能可能抢占当前正在运行的进程。像最短进程优先一样，调度程序正在执行选择函数是必须有关于处理时间的估计，并且存在长进程饥饿的危险。

- **高响应比优先调度算法**

高响应比优先调度算法主要用于作业调度，该算法是对 先来先服务调度算法和短作业优先调度算法的一种综合平衡，**同时考虑每个作业的等待时间和估计的运行时间**。在每次进行作业调度时，**先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行**。

- **优先级调度算法**

优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。

**9、什么是死锁？**

**死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。** 如下图所示：如果此时有一个线程 A，已经持有了锁 A，但是试图获取锁 B，线程 B 持有锁 B，而试图获取锁 A，这种情况下就会产生死锁。

![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/I47RwB1Z6MwBgUOwfFHscBdJsMMn19D6u9bvgpxHZoy78CgEbsmSEOabj3ykrxplc155fvsGicwBzDic6iawIbdBw/640?wx_fmt=png)



**10、产生死锁的原因？**

**由于系统中存在一些不可剥夺资源**，而当两个或两个以上进程占有自身资源，并请求对方资源时，会导致每个进程都无法向前推进，这就是死锁。

- **竞争资源**

例如：系统中只有一台打印机，可供进程 A 使用，假定 A 已占用了打印机，若 B 继续要求打印机打印将被阻塞。

系统中的资源可以分为两类：

1. 可剥夺资源：是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU 和主存均属于可剥夺性资源；

2. 不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。

- **2. 进程推进顺序不当**

例如：进程 A 和 进程 B 互相等待对方的数据。

**11、死锁产生的必要条件？**

1. 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。

2. 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。

3. 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。

4. 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

**12、解决死锁的基本方法？**

1. 预防死锁

2. 避免死锁

3. 检测死锁

4. 解除死锁

**13、怎么预防死锁？**

1. 破坏请求条件：一次性分配所有资源，这样就不会再有请求了；

2. 破坏请保持条件：只要有一个资源得不到分配，也不给这个进程分配其他的资源：

3. 破坏不可剥夺条件：**当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源**；

4. 破坏环路等待条件：**系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反。**

**14、怎么避免死锁？**

- **银行家算法**

**当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。**

当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源。若没超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若满足则按当前的申请量分配资源，否则也要推迟分配。

- **安全序列**

是指系统能按某种进程推进顺序（P1, P2, P3, ..., Pn），为每个进程 Pi 分配其所需要的资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺序地完成。这种推进顺序就叫安全序列【银行家算法的核心就是找到一个安全序列】。

- **系统安全状态** 

如果系统能找到一个安全序列，就称系统处于安全状态，否则，就称系统处于不安全状态。

**15、怎么解除死锁？**

1. 资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程（但应该防止被挂起的进程长时间得不到资源）；

2. 撤销进程：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源（撤销的原则可以按进程优先级和撤销进程代价的高低进行）；

3. 进程回退：让一个或多个进程回退到足以避免死锁的地步。进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。

**16、什么是缓冲区溢出？有什么危害？**

缓冲区为暂时置放输出或输入资料的内存。缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入是否合理。

计算机中，缓冲区溢出会造成的危害主要有以下两点：程序崩溃导致拒绝服务和跳转并且执行一段恶意代码。

**17、分页与分段的区别？**

1. 段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的；

2. **段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定；**

3. 段向用户提供二维地址空间；页向用户提供的是一维地址空间；

4. 段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。

**18、物理地址、逻辑地址、虚拟内存的概念**

1. 物理地址：它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取，**是内存单元真正的地址**。

2. 逻辑地址：是指计算机用户看到的地址。例如：当创建一个长度为 100 的整型数组时，操作系统返回一个逻辑上的连续空间：指针指向数组第一个元素的内存地址。由于整型元素的大小为 4 个字节，故第二个元素的地址时起始地址加 4，以此类推。**事实上，逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址（在内存条中所处的位置），并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维。**

3. 虚拟内存：是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。

**19、页面置换算法有哪些？**

请求调页，也称按需调页，即对不在内存中的“页”，当进程执行时要用时才调入，否则有可能到程序结束时也不会调入。而内存中给页面留的位置是有限的，在内存中以帧为单位放置页面。为了防止请求调页的过程出现过多的内存页面错误（即需要的页面当前不在内存中，需要从硬盘中读数据，也即需要做页面的替换）而使得程序执行效率下降，我们需要设计一些页面置换算法，页面按照这些算法进行相互替换时，可以尽量达到较低的错误率。常用的页面置换算法如下：

- **先进先出置换算法（FIFO）**

先进先出，即淘汰最早调入的页面。

- **最佳置换算法（OPT）**

选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。

- **最近最久未使用（LRU）算法**

即选择最近最久未使用的页面予以淘汰

- **时钟（Clock）置换算法**

时钟置换算法也叫最近未用算法 NRU（Not RecentlyUsed）。该算法为每个页面设置一位访问位，将内存中的所有页面都通过链接指针链成一个循环队列。

**20、谈谈你对动态链接库和静态链接库的理解？**

静态链接就是在编译链接时直接将需要的执行代码拷贝到调用处，优点就是在程序发布的时候就不需要的依赖库，也就是不再需要带着库一块发布，程序可以独立执行，但是体积可能会相对大一些。

动态链接就是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝，缺点是由于是运行时加载，可能会影响程序的前期执行性能。

**--end--**

**21、一个程序从开始运行到结束的完整过程（四个过程）**

预处理：条件编译，头文件包含，宏替换的处理，生成.i文件。

编译：将预处理后的文件转换成汇编语言，生成.s文件

汇编：汇编变为目标代码(机器代码)生成.o的文件

链接：连接目标代码,生成可执行程序

**22、内存池、进程池、线程池。(c++程序员必须掌握)**

  　　首先介绍一个概念“池化技术 ”。**池化技术就是：提前保存大量的资源，以备不时之需以及重复使用。**池化技术应用广泛，如内存池，线程池，连接池等等。内存池相关的内容，建议看看Apache、Nginx等开源web服务器的内存池实现。
  　　由于在实际应用当做，分配内存、创建进程、线程都会设计到一些系统调用**，系统调用需要导致程序从用户态切换到内核态，是非常耗时的操作**。因此，当程序中需要频繁的进行内存申请释放，进程、线程创建销毁等操作时，通常会使用内存池、进程池、线程池技术来提升程序的性能。

  　　**线程池**：线程池的原理很简单，类似于操作系统中的缓冲区的概念，它的流程如下：**先启动若干数量的线程，并让这些线程都处于睡眠状态，当需要一个开辟一个线程去做具体的工作时，就会唤醒线程池中的某一个睡眠线程，**让它去做具体工作，当工作完成后，**线程又处于睡眠状态，而不是将线程销毁。**

  　　**进程池**与线程池同理。

  　　**内存池**：**内存池是指程序预先从操作系统申请一块足够大内存，此后，当程序中需要申请内存的时候，不是直接向操作系统申请，而是直接从内存池中获取**；同理，当程序释放内存的时候，**并不真正将内存返回给操作系统，而是返回内存池**。当程序退出(或者特定时间)时，内存池才将之前申请的内存真正释放。

**23、用户态和核心态**

在讲系统调用之前，先说下**进程的执行在系统上的两个级别**：用户级和核心级，也称为**用户态和系统态(user mode and kernel mode)**。

​           **用户空间就是用户进程所在的内存区域**，相对的，**系统空间就是操作系统占据的内存区域**。用户进程和系统进程的所有数据都在内存中。**处于用户态的程序只能访问用户空间，而处于内核态的程序可以访问用户空间和内核空间。**

**用户态切换到内核态的方式如下：**

- **系统调用**：程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件（这些均属于系统调用）等，就需要向操作系统发出调用服务的请求，这就是系统调用。
- **异常**：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
- **外围设备的中断：**当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

**用户态和核心态(内核态）之间的区别是什么呢？**

​       **权限不一样。**

- **用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据）**。
- **核心态下的进程能够存取内核和用户地址某些机器指令是特权指令，在用户态下执行特权指令会引起错误。**在系统中内核并不是作为一个与用户进程平行的估计的进程的集合。

**24、C++多线程，互斥，同步**

**同步和互斥**

当有多个线程的时候，经常需要去**同步(注：同步不是同时刻)**这些线程以访问同一个数据或资源。例如，假设有一个程序，其中一个线程用于把文件读到内存，而另一个线程用于统计文件中的字符数。当然，在把整个文件调入内存之前，统计它的计数是没有意义的。但是，由于每个操作都有自己的线程，操作系统会把两个线程当作是互不相干的任务分别执行，这样就可能在没有把整个文件装入内存时统计字数。为解决此问题，你必须使两个线程**同步**工作。

所谓**同步**，是指在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。如果用对资源的访问来定义的话，同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。

所谓**互斥**，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。如果用对资源的访问来定义的话，互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。

**多线程同步和互斥有几种实现方法**

线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。

用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。

内核模式下的方法有：事件，信号量，互斥量。

1、临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。 
2、互斥量:为协调共同对一个共享资源的单独访问而设计的。 
3、信号量:为控制一个具有有限数量用户资源而设计。 
4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。

**25、.临界资源**

- 在操作系统中，进程是占有资源的最小单位（线程可以访问其所在进程内的所有资源，但线程本身并不占有资源或仅仅占有一点必须资源）。但**对于某些资源来说，其在同一时间只能被一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源**。典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等(如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题)。
- **对于临界资源的访问，必须是互斥进行。**也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。**而进程内访问临界资源的代码被成为临界区。**

**26、栈和堆的区别**

一、程序的内存分配方式不同

- 栈区（stack）：**编译器自动分配释放**，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构的栈。
- 堆区（heap）：**一般是由程序员分配释放**，若程序员不释放的话，程序结束时可能由OS回收，值得注意的是他与数据结构的堆是两回事，分配方式倒是类似于数据结构的链表。

二、申请方式不同

- stack 由系统自动分配，heap 需要程序员自己申请。
- C 中用函数 malloc分配空间，用 free 释放，C++用 new 分配，用 delete 释放。

三、申请后系统的响应不同

- 栈：只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。
- 堆：首先应该知道操作系统有一个记录内存地址的**链表**，当系统收到程序的申请时，遍历该链表，寻找第一个空间大于所申请的空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，对于大多数系统，会在这块内存空间中的首地址处**记录本次分配的大小**，这样代码中的 delete 或 free 语句就能够正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会将多余的那部分重新放入空闲链表中。

四、 申请的大小限制不同

- 栈：在 windows 下，栈是**向低地址扩展**的数据结构，是一块**连续的内存区域**，栈顶的地址和栈的最大容量是系统预先规定好的，能从栈获得的空间较小。
- 堆：堆是**向高地址扩展**的数据结构，是**不连续的内存区域**，这是由于系统是由链表在存储空闲内存地址，自然堆就是不连续的内存区域，且链表的遍历也是从低地址向高地址遍历的，堆得大小受限于计算机系统的**有效虚拟内存空间**，由此空间，堆获得的空间比较灵活，也比较大。

五、申请的效率不同

- 栈：栈由系统自动分配，**速度快**，但是**程序员无法控制**。
- 堆：堆是有程序员自己分配，**速度较慢，容易产生碎片，不过用起来方便**。

六、堆和栈的存储内容不同

- 栈：在函数调用时，**第一个进栈的是主函数中函数调用后的下一条指令的地址**，然后函数的各个参数，在大多数的 C 编译器中，参数是**从右往左入栈**的，当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令。
- 堆：**一般是在堆的头部用一个字节存放堆的大小**，具体内容由程序员安排。