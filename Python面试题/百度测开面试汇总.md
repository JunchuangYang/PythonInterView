# 百度测开面试汇总

**主要来源牛客网**

1. 自我介绍 	

2. **数据结构有什么，排序算法，哪些是稳定的，哪些不稳定 ？快排的思想以及时间复杂度？**

   `稳定：冒泡、插入、归并`	

3. **http和https的区别？** 	

```
HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐
私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加
密，从而就诞生了HTTPS。 
简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

　　HTTPS和HTTP的区别主要如下：

　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
```

4. **进程和线程的区别？** 	

```markdown
**进程切换比线程切换开销大**:是因为进程切换时要切页表，而且往往伴随着页调度，因为进程的数据段代码段要换
出去，以便把将要执行的进程的内容换进来。本来进程的内容就是线程的超集。
而且线程只需要保存线程的上下文（相关寄存器状态和栈的信息）就好了，动作很小

**为什么切换线程比切换进程开销小**(https://www.cnblogs.com/yvkm/p/10619001.html)
首先要明白进程是什么：
　　关于进程的定义有很多，一个经典的定义是一个执行中程序的实例，进程是程序的动态表现。  
　　一个程序进行起来后，会使用很多资源，比如使用寄存器，内存，文件等。每当切换进程时，必须要考虑保存当前
　　进程的状态。**状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境
　　变量以及打开的文件描述符的集合，这个状态叫做上下文（Context）。可见，想要切换进程，保存的状态还不少。

**其次就要了解线程是什么：**
　　线程存在于进程中，一个进程可以有一个或多个线程。线程是运行在进程上下文中的逻辑流，简单说，线程可以理
　　解为一个方法(Java)或函数（C），这个线程可以独立完成一项任务。同样线程有自己的上下文，包括唯一的整数
　　线程ID， 栈、栈指针、程序计数器、通用目的寄存器和条件码。**可以理解为线程上下文是进程上下文的子集。

**由于保存线程的上下文明显比进程的上下文小，因此系统切换线程时，必然开销更小。**
```

5. **协程**

```markdown
是一种用户态的轻量级线程，协程的调度完全由用户控制。
协程拥有自己的寄存器上下文和栈。
**协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接
  操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快
```

6. **孤儿进程和僵尸进程**

```markdown
**孤儿进程：**一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被
           init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

**僵尸进程：**一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的
          状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

**僵尸进程解决办法**

**（1）通过信号机制**
　　子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。
　　
**（2）fork两次**
　　《Unix 环境高级编程》8.6节说的非常详细。原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。
```

7. **给出一个字符串，找出里面最长不重复字符串** （滑动窗口）	

   [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)(与题意相似，这个是求长度)

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        if not s:
            return 0
        # left:左指针
        left,res,cur = 0,0,0
        word = set()
        for i in range(len(s)):
            cur+=1
            while s[i] in word:
                word.remove(s[left])
                left += 1
                cur -= 1
            word.add(s[i])
            res = max(cur,res)
        return res# 长度
```

8. **liunx命令，shell命令** 	

9. **三个数之和为0（排序+二分查找：去重）**

   [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()# 排序
        #print(nums)
        res = []
        for i in range(len(nums)):
            if i-1 >=0 and nums[i]==nums[i-1]:# 去重
                continue
            if nums[i]>0:# 特判
                break
            left,right = i+1,len(nums)-1
            target = -nums[i] # 固定一个数，求另外两个数的和等于target的负数
            while left<right:# 二分
                num = nums[left]+nums[right]
                if num > target:
                    right -= 1
                elif num < target:
                    left += 1
                else:
                    res.append([nums[i],nums[left],nums[right]])
                    # 去重
                    while left<right and nums[left] == nums[left+1]:
                        left += 1
                    while left<right and nums[right] == nums[right-1]:
                        right -= 1
                    left+=1
                    right-=1
        return res
```

10. **算法题（讲思路）：不用变量 temp 交换两变量（int型）**

11. **百度搜索框输入几个字，所涉及到的所有计算机网络的知识点；**

    ```markdown
    首先明确：建立一个完整的socket连接需要的5个参数，
    **分别是：(本机ip，本机端口号，使用的网络协议，要访问的机器的ip，要访问机器的端口号)
    
    假设访问百度，输入www.baidu.com,然后回车:
    1.**此时要确定的是百度的ip地址，使用dns协议，向dns服务器发送数据包（dns服务器开启的是53端口），
    DNS服务器返回给我们百度的ip地址。**利用子网掩码判断要访问的ip是否和本地主机是同一个网段，假设要访
    问的ip跟我们不是同一个网段，那么向百度发送数据包必须通过网关转发。
    
    2.基于TCP三次握手建立连接
    
    3.接下来通过应用层，浏览器访问使用的是http协议，构造一个http数据包。假定其长度为4960个字节，他会被
      嵌在tcp数据包之中。
    
    4.然后传输层，Tcp数据包需要设置端口，接收方的默认端口是80，本机的端口是一个随机生成的1024到65535
      之间的整数。假定为8888。Tcp数据包的包头长度为20字节，加上http数据包，为4980字节。
    
    5.然后经过网络层，tcp数据包再嵌入ip数据包，ip数据包需设置双方ip【已知】。Ip数据包的头长度为20字
      节，总共是5000字节。IP数据包经过网关转发，进入以太网。
    
    6.接下来到数据链路层。Ip数据包嵌入以太网数据包，以太网数据包需设置双方mac地址【已知】，接收方mac地
      址即网关mac地址【通过arp协议得到】。以太网数据包的数据部分最大为1500字节，因此ip数据包必须分包，
      因为每个包都有自己的ip标头，因此四个包的ip数据包的长度分别是1500，1500，1500，560。
    
    7.然后是物理层。物理线路则只负责该数据以bit为单位从主机传输到下一个目的地。下一个目的地接受到数据
      后，从物理层得到数据然后经过逐层的解包到链路层到网络层。
    
    8.然后开始上述的处理，在经网络层、链路层、物理层将数据封装好继续传往下一个地址。
    
    原文链接：https://blog.csdn.net/qq_35075909/article/details/91969830
    ```

12. **算法题（写代码并结合测试案例完善代码）：字符串逆置**

13. **算法题（写代码并结合测试案例完善代码）：两链表找公共子节点**

14. **编程：topK问题，时间复杂度（说思路）**

`大根堆、小根堆`

15. **编程：两个栈实现一个队列（说思路)**

16. 内存泄漏了解吗？哪些情况下会出现内存泄漏？

    ```markdown
    1>当程序在申请内存后,,无法释放已经申请的内存空间(例如一个对象或者变量使用完成后没有释放,
      这个对对象一直占用着内存),一次内存泄漏的危害可以忽略,但是内存泄露堆积的后果很严重,
      无论多少内存,迟早会被占光,内存泄露最终会导致内存溢出
    
    2>当程序申请内存时,没有足够的内存空间供其使用,出现了out of memory;比如申请了一个int,
      但给他存放了long才能存下的数,就是内存溢出.
    
    **循环引用
    ```

17.  **如微信中哪里会出现内存泄漏？**

18. **线程和进程的区别？多线程和多进程的区别？**

19. **两根绳子，每根燃尽都是1小时，怎么得到15分钟的时间？** 

`同时燃烧两根根，等到一根燃烧一半的时候点燃另一头，等到一根烧完的时候另一根就剩15分钟的时间。`

20. **输入一个网址，会涉及到哪些知识？**

- 以下是一个大概流程：
- 1. 浏览器向DNS服务器查找输入URL对应的IP地址。
  2. DNS服务器返回网站的IP地址。
  3. 浏览器根据IP地址与目标web服务器在80端口上建立TCP连接
  4. 浏览器获取请求页面的html代码。
  5. 浏览器在显示窗口内渲染HTML。
  6. 窗口关闭时，浏览器终止与服务器的连接。

21. **问项25匹马的问题，要取得前5名，5个跑道，要比多少次可以得出前5名？**  

<https://blog.csdn.net/Xu_JL1997/article/details/89021916>

22. **重载和重写的区别**

```markdown
**重写（overwrite） 和 重载（overload）**

- **重载：**
- 1. **发生在同一个类中**
  2. 相同的方法名
  3. 参数列表不同
  4. 不看返回值，如果出现了只有返回值不同的“重载”，是错的。
- **重写：**
- 1. **发生在子类与父类中**
  2. 相同的方法名
  3. 相同的参数列表
  4. 返回值相同 或者 子类方法的返回值是父类方法返回值类型的子类
  5. 访问修饰符相同 或者 子类方法的修饰符范围 大于 父类
  6. 抛出的异常相同 或者 子类方法抛出的异常 小于父类
```

23. **全局变量和局部变量的区别**

```markdown
- 全局变bai量du和局部变量的区别如下：

- 1. 作用域不同：全局变量的作用域为整个程序，而局部变量的作用域为当前函数或循环等
  2. 内存存储方式不同：全局变量存储在全局数据区中，局部变量存储在栈区
  3. 生命期不同：全局变量的生命期和主程序一样，随程序的销毁而销毁，局部变量在函数内部或循环内部，
     随函数的退出或循环退出就不存在了
  4. 使用方式不同：全局变量在声明后程序的各个部分都可以用到，但是局部变量只能在局部使用。
  	 函数内部会优先使用局部变量再使用全局变量。
```

24. **实现多线程的方法有哪些**

25. **输入一个文件地址和字符串aaa，要求输出aaa所在的那行的所有字符串**

```python
with open('1.txt','r') as f:
    # print("ddd")
    # s = f.readlines()
    # for sta in s:
    #     if 'aaa' in sta:
    #         print(sta,end='')
    while True:
        s = f.readline()
        if not s:
            break
        if 'aaa' in s:
            print(s,end='')
```

26. **有一个字典对象[{1:2},{12:2},{3:4},{2:7}],需要按照key值，从小到大进行排序，返回排序后的list对象。**

```python
nums = [{10:2},{2:3},{3:4},{4:5}]
nums.sort(key = lambda x:list(x.keys())[0])
```

27. **各种排序算法区别**

28. **现场写快速排排**
29. **TCP和UDP区别**

```markdown
TCP和UDP编程区别

TCP编程的服务器端一般步骤是： 
　　1、创建一个socket，用函数socket()； 
　　2、设置socket属性，用函数setsockopt(); * 可选 
　　3、绑定IP地址、端口等信息到socket上，用函数bind(); 
　　4、开启监听，用函数listen()； 
　　5、接收客户端上来的连接，用函数accept()； 
　　6、收发数据，用函数send()和recv()，或者read()和write(); 
　　7、关闭网络连接； 
　　8、关闭监听； 

　　TCP编程的客户端一般步骤是： 
　　1、创建一个socket，用函数socket()； 
　　2、设置socket属性，用函数setsockopt();* 可选 
　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 
　　4、设置要连接的对方的IP地址和端口等属性； 
　　5、连接服务器，用函数connect()； 
　　6、收发数据，用函数send()和recv()，或者read()和write(); 
　　7、关闭网络连接；

与之对应的UDP编程步骤要简单许多，分别如下： 
　　UDP编程的服务器端一般步骤是： 
　　1、创建一个socket，用函数socket()； 
　　2、设置socket属性，用函数setsockopt();* 可选 
　　3、绑定IP地址、端口等信息到socket上，用函数bind(); 
　　4、循环接收数据，用函数recvfrom(); 
　　5、关闭网络连接； 

　　UDP编程的客户端一般步骤是： 
　　1、创建一个socket，用函数socket()； 
　　2、设置socket属性，用函数setsockopt();* 可选 		
　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 
　　4、设置对方的IP地址和端口等属性; 
　　5、发送数据，用函数sendto(); 
　　6、关闭网络连接；
```

30. **进程和线程了解多少**

31. **单链表如何判断有环**

    `快慢指针`

32. **两个有序列表连接成一个有序表** 

33. **vim查找一个文件定位到第几行** 

```
使用vim 打开文件时，默认情况下光标会停留在文件开头，有时候文件比较大，翻阅和查找都比较麻烦，
怎样在打开的时候直接定位到某一行呢？

vim +n filename ：打开文件，并将光标置于第n行首 

vim +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处

其他补充
    显示行号：命令模式下set nu

    定位到指定行：

    命令模式下，:n   比如想到第2行，:2

    编辑模式下，ngg  比如想到第5行 5gg(或者5G)

    打开文件定位到指定行   vim  +n  test.txt

    查看当前行信息 ctrl+g (显示类似信息："start_computer.sh" 13 行 --30%-- )
```

30. **数据库范式** 
31. **python**简单说说日常用到了什么 
32. **字典排序** 

```python
mydict = {2: '小路', 3: '黎明', 1: '郭富城', 4:'周董'}

按键排序
1.sorted(mydict.items(),key=lambda mydict:mydict[0],reversed=True)

按值排序
1.sorted(mydict.items(),key=lambda mydict:mydict[1],reversed=True)

sorted并不改变字典本身的数据次序。
```

30. **Linux相关** 

```
查询进程 磁盘 

[Linux查询进程和结束进程](https://www.cnblogs.com/liutao1122/p/8268932.html)

1.ps -ef |grep redis:这条命令的意思是显示有关redis有关的进程

    ps:将某个进程显示出来
    -A 　显示所有程序。
    -e 　此参数的效果和指定"A"参数相同。
    -f 　显示[UID]栏位。
    grep命令是查找
    中间的|是管道命令 是指ps命令与grep同时执行
ps -elf:
    -e：显示系统内的所有进程信息。

    -l：使用长（long）格式显示进程信息。

    -f：使用完整的（full）格式显示进程信息。
    
2.ps aux
    ps命令用于报告当前系统的进程状态。可以搭配kill指令随时中断、删除不必要的程序。ps命令是最基本同时也
    是非常强大的进程查看命令，使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有
    僵死、哪些进程占用了过多的资源等等，总之大部分信息都是可以通过执行该命令得到的。

    a：显示当前终端下的所有进程信息，包括其他用户的进程。

    u：使用以用户为主的格式输出进程信息。

	x：显示当前用户在所有终端下的进程。

3.top
以全屏交互式的界面显示进程排名，及时跟踪包括CPU、内存等系统资源占用情况，默认情况下每三秒刷新一次，其作
用基本类似于Windows系统中的任务管理器。

4.kill[参数][进程号]

   kill -9 4394

    kill就是给某个进程id发送了一个信号。默认发送的信号是SIGTERM，而kill -9发送的信号是SIGKILL，即exit。
    exit信号不会被系统阻塞，所以kill -9能顺利杀掉进程。当然你也可以使用kill发送其他信号给进程。

5.显示监听的端口使用命令“netstat -l”可以显示已经监听的端口。


6.查看磁盘整体情况
　 命令：df
　 参数：
　　　　-a：列出所有的文件系统，包括系统特有的/proc等文件系统

　　　　-k：以KB的容量显示各文件系统

　　　　-m：以MB的容量显示各文件系统

　　　　-h：以人们较易阅读的GB,MB,KB等格式自行显示

　　　　-H：以M=1000K替代M=1024K的进位方式

　　　　-T：显示文件系统类型

　　　　-i：不用硬盘容量，而以inode的数量来显示

　　　　-l：只显示本机的文件系统
　　df -h 将结果以易读的方式显示
　　
7.查询指定目录都磁盘占用情况

　　命令：du
　　参数：
　　　　-a : 列出所有的文件与目录容量，默认仅统计目录下面的文件量；

　　　　-h : 以人们较易读的容量格式（G/M）显示；

　　　　-s : 列出目录及子目录下文件总容量，而不列出每个个别的目录占用了容量；

　　　　-S : 不包含子目录的占用量，与-s有点差别；

　　　　-k : 以KB列出容量显示；

　　　　-m : 以MB列出容量显示

　　　　--max-depth=1：子目录深度

　　　　-c：列出明细的同时，增加汇总值。
　　　　
　　du -sh *
　　在命令行中输入 “du -sh *”可以查看每个文件夹的大小。此举可以快速定位大文件所存在的位置。

Linux的一些命令: 
    - cat     由第一行开始显示内容，并将所有内容输出
    - tac     从最后一行倒序显示内容，并将所有内容输出
    - more    根据窗口大小，一页一页的现实文件内容
    - less    和more类似，但其优点可以往前翻页，而且进行可以搜索字符
    - head    只显示头几行
    - tail    只显示最后几行
    - nl      类似于cat -n，显示时输出行号
    - tailf   类似于tail -f 

 	动态查看文件命令 
```

31. 事务

32. 浅拷贝深拷贝 

33. 测试微信语音  

34. 对测试开发的理解 

35. 说说测试的方法 

    [常见的软件测试方法及汇总](https://www.cnblogs.com/zhuminghui/p/10788968.html)

36. 黑盒白盒测试的理解并举例

    **同上**

37. list怎么拼接，增加元素，又同样的问题问了字典怎么做 

**字典添加元素的三种方式：**

```
book_dict = {"price": 500, "bookName": "Python设计", "weight": "250g"}
 
 
book_dict["owner"] = "tyson" 

#第一种方式：指定key，为其赋值一个value，如果key在dict中已存在
则是修改key对应的value，不存在就会添加一个Entry（key-value）到字典中
 
 
book_dict.update({"country": "china"}) 

#第二种方式：使用dict的特有的update方法,为其传入一个dict对象进去
如果key已经在当前字典中存在，则会覆盖掉原有的value
key不存在则是添加一个或多个Entry（key-value）到当前字典中
这取决于你传入的dict对象里有多少个元素【注意：此处一个元素指一个Entry（key-value）】
 
 
book_dict.update(temp = "无语中", help = "帮助") 

#第三种方式：同样使用dict的update方法，但传入的是关键字参数，若key存在则是修改value，
key不存在则是添加一个或多个Entry进去【注意：关键字参数形式，取决于你为update方法传入
几个关键字参数，此种方式的key对象只能是字符串对象】
 
 
#注意：字典中的Entry是无序的
#注意：遍历字典的时候，与你添加元素的顺序、访问元素的顺序均无关，当你遍历字典的时候，
如果恰巧与你添加的元素的顺序是一样的，仅仅是巧合而已，需要有序字典请看OrderDict
```

31. 测试百度知道 ,测试一支笔 
32. 数据库查询语句 
33. tcp和udp的区别,三次握手 
34. Linux查内存 ,查端口号 ，简单的Linux命令 ，动态查看文件命令

**查内存**<https://www.linuxidc.com/Linux/2018-12/155735.htm>

```
free命令
vmstat命令
/proc/meminfo命令
top命令
htop命令
```

**查端口号**：

```
1. lsof -i:端口号 用于查看某一端口的占用情况
   lsof -i:8080
2. netstat -tunlp | grep 端口号，用于查看指定端口号的进程情况
   netstat -tunlp | grep 8080
	
   几个参数含义:
    -t (tcp) 仅显示tcp相关选项
    -u (udp)仅显示udp相关选项
    -n 拒绝显示别名，能显示数字的全部转化为数字
    -l 仅列出在Listen(监听)的服务状态
    -p 显示建立相关链接的程序名
```

**查看文件**

```
cat #将文件内容输出到屏幕
head #查看文件开头N行
tail #查看文件末尾N行
tailf #动态的查看的写入，有写入时屏幕输出
vim、vi #文件编辑器，也可以当是查看文件{进入文件}
grep #查看特定的字符行
sed #这个是不进入文件里面修改文件，可以看文件的
awk #这个是按列查看文件
grep/sed/awk #这是文本三剑客，对字符的筛选，替换，修改，这三个比较重要的
```

**打印文件第几行**

```linux
sed -n 4,8p file #打印file中的4-8行
sed -n 4p file #打印file中的第4行
```

**查看80端口的占用情况**

`ps -ef | grep 80`

**HTTP状态码**

`304:未修改 502：bad gateway`

35.**浏览器框中输入、、、后台服务的过程**

36. **概率生成器**<https://www.cnblogs.com/lfri/p/12427656.html>

```
问题一：

已知一随机发生器，产生0的概率是p，产生1的概率是1-p，现在要你构造一个发生器，使得它构造0和1的概率均为1/2；

构造一个发生器，使得它构造1、2、3的概率均为1/3；…， 
构造一个发生器，使得它构造1、2、3、…n的概率均为1/n，要求复杂度最低。

解决方法：

原始的随机数生成器，生成0 的概率为p,生成1的概率为1-p,那么怎么构造才能使得生成0和1的概率相等呢。
或者说有两个独立的事件的概率是相等呢？

这样来做一下，让该随机数生成器生成两个数，那么序列是00,01,10,11概率分别为 p*p,p(1-p),(1-p)p,(1-p)*(1-p)

很明显，这四种情况中存在两个独立的事件概率是相等。也就是01和10，那么我把01看成是0,10看成是1，那么他们输出的概率均为p(1-p)，其他的情况舍弃。这样就得到了0和1均等生成的随机器了。

这种解法可以推广到n个数的情况，我们知道，取n个随机数发生器，存在n个概率相同的独立事件，我们只使用这n个事件就得到1/n的概率了。例如n=3,有8中情况000,001,010,011,100,101,110,111，其中001,010,100的概率都是p^2*(1-p)。

问题二：已知有个rand7()的函数，返回1到7随机自然数，让利用这个rand7()构造rand10() 随机1~10。

解决方案：这个问题和上个问题不同的是，这里产生的序列，要变成和的形式或者其他的形式，那么概率就会发生变化了。

如果能够得到一组等概率的数，不管是什么数，只要等概率而且个数大于10，那么问题就可以解决了。

发现(rand7()-1)*7+rand7(),可以等概率的生成1到49。

呵呵，这不就得了，只要把11-49砍掉就可以了。不过这样的效率比较低。可以砍掉41-49，然后在把1-40映射到1-10（例如模10），那么问题也就解决了。
```

36. [4G 内存处理 10G 大小的文件](https://www.cnblogs.com/miaoweiye/p/12612311.html)

```python
下面的讨论基于的假定：可以单独处理一行数据，行间数据相关性为零。

方法一：

仅使用 Python 内置模板，逐行读取到内存。

使用 yield，好处是解耦读取操作和处理操作：

def python_read(filename):
    with open(filename,'r',encoding='utf-8') as f:
        while True:
            line = f.readline()
            if not line:
                return
            yield line
以上每次读取一行，逐行迭代，逐行处理数据

if __name__ == '__main__':
    g = python_read('./data/movies.dat')
    for c in g:
        print(c)
        # process c
```

36. **linux创建文件命令多个**<https://linux.cn/article-10549-1.html>

```
>：标准重定向符允许我们创建一个 0KB 的空文件。
	$ > daygeek.txt

touch：如果文件不存在的话，touch 命令将会创建一个 0KB 的空文件。
	$ touch daygeek1.txt
	
echo：通过一个参数显示文本的某行。
	$ echo "2daygeek.com is a best Linux blog to learn Linux" > daygeek2.txt
		
printf：用于显示在终端给定的文本。
	$ printf "2daygeek.com is a best Linux blog to learn Linux\n" > daygeek3.txt

cat：它串联并打印文件到标准输出。
	$ cat > daygeek4.txt
	如果你想向同一个文件中添加其他内容，使用两个连接的重定向符（>>）。
	$ cat >> daygeek4.txt

vi/vim：Vim 是一个向上兼容 Vi 的文本编辑器。它常用于编辑各种类型的纯文本。
	$ vi daygeek5.txt

nano：是一个简小且用户友好的编辑器。它复制了 pico 的外观和优点，但它是自由软件。
	$ nano daygeek6.txt
	
head：用于打印一个文件开头的一部分。
	$ head -c 0K /dev/zero > daygeek7.txt

tail：用于打印一个文件的最后一部分。
	$ tail -c 0K /dev/zero > daygeek8.txt

truncate：用于缩小或者扩展文件的尺寸到指定大小。
	$ truncate -s 0K daygeek9.txt
```



36. **没有网络你怎么办**

```
1.考虑是固定IP还是DHCP，如果是固定IP则检查是否不小心把IP给设置成了DHCP选项。

2.看右下角小电脑图标是感叹号还是叉叉，如果是感叹号说明物理连通性还是没有问题，如果是叉叉则有可能是网线没
插好，或者网线在交换机上没插好，再就是把网卡驱动更新一下

3.考虑到别人能上网而你不能，则PING一下网关是否可以通讯，DNS是否设置正确

4.如果arp设置成了MAC和IP绑定，或者是MAC网关绑定，则检查是否有人在路由器删掉了你的IP和网关MAC之间的绑定

5.防火墙限制了你的IP或者端口上网能力，检查防火墙设置

作者：孤岂能止步于咸阳
链接：https://www.zhihu.com/question/64925497/answer/227227529
```

38.**C指针和引用**

```
1、引用：
C++是C语言的继承，它可进行过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行
以继承和多态为特点的面向对象的程序设计。引用就是C++对C语言的重要扩充。引用就是某一变量的一个别名，对引用
的操作与对变量直接操作完全一样。引用的声明方法：类型标识符 &引用名=目标变量名；引用引入了对象的一个同义
词。定义引用的表示方法与定义指针相似，只是用&代替了*。

2、指针：
指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地
址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。

区别：
1、指针有自己的一块空间，而引用只是一个别名；

2、使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；

3、指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象的引用；

4、作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；

5、可以有const指针，但是没有const引用；

6、指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；

7、指针可以有多级指针（**p），而引用至于一级；

8、指针和引用使用++运算符的意义不一样；

9、如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。
```

