# 面试题1

**1、请拿出A表(id,name)和B表中一样的数据**

`select * from A inner join on B.name = A.name`

**2、str = “abbbccc”，用正则匹配为abccc,不管有多少b，就出现一次？**

不管有多少b，都替换成一个

`re.sub(r'b+','b',str)`

**3、xpath 使用的什么库？**`lxml`

**4、py2 和py3 的区别？**

`1、py2 的默认编码是ASCII，py3的默认编码是UTF-8`

`2、py2中print函数可以用引号引起来也可以括起来执行，py3必须括号括起来执行`

`3、py2交互使用函数raw_input()得到了str，input()得到了int数据类型，py3使用input() 得到str`

`4、py2 有range()和xrange(),py3只有range() ，是可迭代对象`

`5、py2的除法不是浮点数只返回商，整除一样，py3的除法返回小数，整除同py2`

**5、Redis中list内容的长度？** `LLEN KEY_NAME `

**6、多线程交互，访问数据，如果访问到了就不访问了，怎么避免重读？**

`创建一个已访问数据列表，用于存储已经访问过的数据，并加上互斥锁，在多线程访问数据的时候先查看数据是否在已访问的列表中，若已存在就直接跳过。`

**7、Mysql 怎么限制IP 访问？**

`grant all privileges on . to “数据库中用户名”@“ip地址” identified by “数据库密码”;`

` #授权某个ip的用户可以通过密码访问数据库`

**8、带参数的装饰器。**

```python
# 带定长参数的装饰器
def new_func(func):
    def wrappedfun(username,passwd):
		pass
    return wrappedfun
@new_func
def orign():
    print('开始执行函数')
orign('root','123456789')
---------------------------------------------------------------------------
# 带不定长参数的装饰器
def new_func(func):
    def wrappedfun(*args):
		pass
    return wrappedfun
@new_func
def orign():
    print('开始执行函数')
orign('root','123456789')
---------------------------------------------------------------------------
# 带不定长、关键字参数的装饰器
def new_func(func):
    def wrappedfun(*args,**kwargs):
		pass
    return wrappedfun
@new_func
def orign():
    print('开始执行函数')
orign('root','123456789',kw=1,kw=2)

```

**9、什么是线程安全？什么是互斥锁？**
`每个对象都对应于一个可称为’互斥锁‘的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。`

`同一进程中的多线程之间是共享系统资源的，多个线程同时对一个对象进行操作，一个线程操作尚未结束，另一线程已经对其进行操作，导致最终结果出现错误，此时需要对被操作对象添加互斥锁，保证每个线程对该对象的操作都得到正确的结果。`

**10、Python 主要的内置数据类型有哪些？**

```
**简单数据类型**

1. 整形 int
2. 浮点型float
3. 复数类型complex
4. 布尔类型bool

**容器类型**

1. 字符串str
2. 元组tuple
3. 列表list
4. 集合类型set
5. 字典类型dict
```

**11、print(dir('a'))输出的是什么？**

`会打印出字符型的所有内置方法。`

**12、给定两个list，A 和B，找出相同元素和不同元素？**

`A、B中相同元素：print(set(A)&set(B))`

`A、B中不同元素：print(set(A)^set(B))`

```python
A = [1,2,3,4,5]
B = [3,4,5,6,7]
C = []
D = []
# 相同元素
for i in A:
    if i in B:
        C.append(i)
# 不同元素
for i in A+B:
    if i not in A:
        D.append(i)
    if i not in B:
        D.append(i)
print(C,D)
```

**13、请反转字符串？**`new_str = str[::-1] `

**14、交换变量a,b 的值？**`a,b=b,a`

**15、用select语句输出每个城市中心距离市中心大于20km 酒店数？**

`select count(hotel) form hotel_table where distance > 20 group by city`

**16、给定一个有序列表，请输出要插入值k 所在的索引位置？**

```python
def index(list, key):
    if key < list[0]:
        position = 0
    elif key > list[-1]:
        position = len(list)
    else:
        # for循环内部还可以使用二分
        for i in range(len(list)-1):
            if (key >= list[i]) and (list[i + 1] > key):
                position = i + 1
    return position
```

**17、正则表达式贪婪(.\*)与非贪婪(.*?)模式的区别？**

`在形式上非贪婪模式有一个“？”作为该部分的结束标志。`

`在功能上贪婪模式是尽可能多的匹配当前正则表达式，可能会包含好几个满足正则表达式的字符串，非贪婪模式，在满足所有正则表达式的情况下尽可能少的匹配当前正则表达式。`

**18、写出开头匹配字母和下划线，末尾是数字的正则表达式？**

`^[A-Za-z]|_.*\d$`

**19、请说明HTTP 状态码的用途，请说明常见的状态码机器意义？**

```
通过状态码告诉客户端服务器的执行状态，以判断下一步该执行什么操作。

常见的状态机器码有:
100-199：表示服务器成功接收部分请求，要求客户端继续提交其余请求才能完成整个处理过程。100	(continue继续。客户端继续其请求)

2xx：成功--表示请求已被成功接收、理解、接受

　　200（成功）  服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。

　　204（无内容）  服务器成功处理了请求，但未返回任何内容。

　　205（重置内容） 服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）。

　　206（部分内容）  服务器成功处理了部分 GET 请求。

3xx：重定向--要完成请求必须进行更进一步的操作

　　300（多种选择）  服务器根据请求可执行多种操作。服务器可根据请求者 来选择一项操作，或提供操作列表供其选择。 

　　301（永久移动）  请求的网页已被永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。您应使用此代码通知搜索引擎蜘蛛网页或网站已被永久移动到新位置。

　　302（临时移动） 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。会自动将请求者转到不同的位置。但由于搜索引擎会继续抓取原有位置并将其编入索引，因此您不应使用此代码来告诉搜索引擎页面或网站已被移动。

　　304（未修改） 自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。

　　305（使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。

4xx：客户端错误--请求有语法错误或请求无法实现

　　400（错误请求） 服务器不理解请求的语法。 

　　401（身份验证错误） 此页要求授权。您可能不希望将此网页纳入索引。

　　403（禁止） 服务器拒绝请求。

　　404（未找到） 服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。

　　406（不接受） 无法使用请求的内容特性响应请求的网页。

　　408（请求超时） 服务器等候请求时发生超时。

　　414（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。

5xx：服务器端错误--服务器未能实现合法的请求

　　500（服务器内部错误）  服务器遇到错误，无法完成请求。

　　503（服务不可用） 目前无法使用服务器（由于超载或进行停机维护）。通常，这只是一种暂时的状态。

　　504（网关超时）  服务器作为网关或代理，未及时从上游服务器接收请求。

　　505（HTTP 版本不受支持） 服务器不支持请求中所使用的 HTTP 协议版本
　　
https://www.cnblogs.com/taider/p/10716059.html
```

**20、当输入http:mioji3.com时，返回页面的过程中发生了什么？**

```
1.DNS解析
    DNS解析的过程就是寻找哪台机器上有你需要资源的过程，寻找的过程遵循就近原则。
    输入一个网址并按回车的时候浏览器会根据输入的URL去查找对应的IP(就是根据输入的URL查找对应	的IP），过程如下：

    DNS根据域名查询IP地址的过程为：浏览器缓存 --> 操作系统缓存 --> 路由器缓存–>本地		（ISP）域名服务器缓存 --> 根域名服务器。

2.进行TCP连接
	这时候浏览器终于得到了IP以后，向服务器发送TCP连接，TCP连接经过三次握手。

3.浏览器发送HTTP请求
4.服务器处理请求
5.浏览器解析渲染页面
    1）浏览器显示HTML
    2）浏览器向服务器发送请求获取嵌入在HTML中的对象
    3）浏览器发送异步（AJAX）请求

6.关闭TCP连接
    当数据完成请求到返回的过程之后，根据Connection的Keep-Alive属性可以选择是否断开TCP连	接。
    TCP的断开与连接不一样，断开可以分为主动关闭和被动关闭，需要经过4次握手。

最后 当浏览器需要的全部数据都已经加载完毕，一个页面就显示完了。

原文链接：https://blog.csdn.net/weixin_44183254/java/article/details/88745460
```

**21、有一个多层嵌套列表A=[1,2,[3.4[“434”,[…]]]]请写一段代码遍历A中的每一个元素并打印出来。**

`思路：写个递归函数，做迭代输出`

```python
def flat(nums):
    res = []
    for i in nums:
        if isinstance(i,list):
            res.extend(flat(i))
        else:
            res.append(i)
    return res

alist=[1,[2,3,[4,5,[6,7,[8,[9,[10],11],12],13],14],15],16]
a=flat(alist)
print(a)
```

**22、关系型数据库中，表和表之间有左连接，内连接，外连接，分别解释下他们的含义和区别？**

```sql
-- ----------------------------
-- NATURAL JOIN，自然连接，无ON子句；选取值相同的行，并把相同列合并成一列
-- ----------------------------
SELECT * FROM student NATURAL JOIN score;
————————————————
-- ----------------------------
-- INNER JOIN，等值连接，有ON子句；选取两表中，值相同的行
-- ----------------------------
SELECT * FROM student INNER JOIN score ON student.id = score.id;
————————————————

-- ----------------------------
-- LEFT OUTER JOIN，左外连接，有ON子句；选取值相同的行，和左表不匹配的行
--查询的结果为两个表匹配到的数据，左表特有的数据，对于右表中不存在的数据使用null 填充。
-- ----------------------------
SELECT * FROM student LEFT OUTER JOIN score ON student.id = score.id;
————————————————
-- ----------------------------
-- RIGHT OUTER JOIN，右外连接，有ON子句；选取值相同的行，和右表不匹配的行
-- 查询的结果为两个表匹配到的数据，右表特有的数据，对于左表中不存在的数据使用 null填充。
-- ----------------------------
SELECT * FROM student RIGHT OUTER JOIN score ON student.id = score.id;
————————————————

原文链接：https://blog.csdn.net/gaojinshan/java/article/details/22158719
```

**23、如何定时启动你的爬虫项目?**

`最简单的方法：直接使用 Time 类；`

```python
import time
import os
while True:
    os.system("scrapy crawl News")
    time.sleep(86400) #每隔一天运行一次 24*60*60=86400s
```

**24、什么是 scrapy-redis 中的指纹,是如何去重的？**

`指纹：通过 MD5 加密，把请求体，请求方式，请求 url 放在一起。然后进行 32 进制的转义符字符串生成指纹。生成一个字符串，放到数据库中作为唯一标示。`

`去重：urll 中按照 url 去重：
1.按照 url 去重，有一个列表，发送请求之前从数据表中看一下这个 url 有没有请求过，请求过了就不用看了
2，内容判断，从数据库中查数据的表示，如果请求过了就在不在请求了。`

**25、代码优化从哪些方面考虑？有什么想法？**

```
1.优化算法时间复杂度。
	算法的时间复杂度对程序的执行效率影响最大，在 Python 中可以通过选择合适的数据结构来优化时	间复杂度，如 list 和 set 查找某一个元素的时间复杂度分别是 O(n)和 O(1)。不同的场景有不	同的优化方式，总得来说，一般有分治，分支界限，贪心，动态规划等思想。
2.减少冗余数据。
3.合理使用 copy 与 deepcopy。
4.使用 dict 或 set 查找元素。
5.合理使用生成器（generator）和 yield。
6.优化循环。
7.不借助中间变量交换两个变量的值。
8.while 1 比 while True 更快。
9.使用**而不是 pow。
10.并行编程
    因为 GIL 的存在，Python 很难充分利用多核 CPU 的优势。但是，可以通过内置的模块

    multiprocessing 实现下面几种并行模式：

    多进程：对于 CPU 密集型的程序，可以使用 multiprocessing 的 Process，Pool 等封装好的		类， 通过多进程的方式实现并行计算。但是因为进程中的通信成本比较大，对于进程之间需要大量数		据交互的程序效率未必有大的提高。

    多线程：对于 IO 密集型的程序，multiprocessing.dummy 模块使用 multiprocessing 的接		口封装 threading，使得多线程编程也变得非常轻松(比如可以使用 Pool 的 map 接口，简洁	高效)。

```

**26、Django 项目的优化（web 通用）**

```
1.优化数据库查询
    1.1 一次提供所有数据
    1.2 仅提供相关的数据
2.代码优化
    2.1 简化代码
    2.2 更新或替代第三方软件包
    2.3 重构代码
```

**27、定义A=(“a”, “b”, “c”, “d”),执行delA[2]后的结果为：** `异常`

**28、String = “{1},{0}”; string = string.format(“Hello”, “Python”),请问将string 打印出来为（C）？**

`Python Hello`

**29、定义A=[1,2,3,4],使用列表生成式[i*i for i in A]生成列表为：**

`[1,4,9,16]`

**30、请对Python 数据结构Tuple,List,Dict 进行操作？**

`1. 如何让元祖内部可变（叙述或简单定义）? `

`元祖变成列表：A=list（a）`

`2.如何将L1 = [1,2,3,4],L2 = [6,7,8,9];使用列表内置函数变成L1=[1,2,3,4,5,6,7,8,9]?L1.extend(L2)`

`3.如何将字典D={‘Adam’: 95, ‘Lisa’: 85, ‘Bart’: 59}中的值’Adam’删除?`

`del D['Adam']`

`4.请按照如下格式K：V 打印出字典?`

`for k , v in dir.items():`

​	`print(k,":",v)`

