# 奇安信

### **1、Python中threading的join和setDaemon的区别及用法**

1、**join ()方法：**主线程A中，创建了子线程B，并且在主线程A中调用了B.join()，那么，主线程A会在调用的地方等待，直到子线程B完成操作后，才可以接着往下执行，那么在调用这个线程时可以使用被调用线程的join方法。

2、**setDaemon()方法。**主线程A中，创建了子线程B，并且在主线程A中调用了B.setDaemon()，这个的意思是，把主线程A设置为守护线程，这时候，要是主线程A执行结束了，就不管子线程B是否完成，一并和主线程A退出.这就是setDaemon方法的含义，这基本和join是相反的。此外，还有个要特别注意的：必须在start() 方法调用之前设置。

### **2、is和==的区别**

is：每个对象都有一个唯一的身份信息, 可以用id()获取就是数据(对象)的内存地址, is比较的就是这个值

==：比较的是左右两边的值

[python小数据池，代码块的最详细、深入剖析](https://www.cnblogs.com/jin-xin/articles/9439483.html)

**代码块的缓存机制：机制内容：**在同一个代码块内，Python在执行同一个代码块的初始化对象的命令时，会检查是否其值是否已经存在，如果存在，会将其重用。

换句话说：执行同一个代码块时，遇到初始化对象的命令时，他会将初始化的这个变量与值存储在一个字典中，在遇到新的变量时，会先在字典中查询记录，如果有同样的记录那么它会重复使用这个字典中的之前的这个值。所以在你给出的例子中，文件执行时（同一个代码块）会把i1、i2两个变量指向同一个对象，满足缓存机制则他们在内存中只存在一个，即：id相同。

**字符串缓存机制：**

​	1，非乘法得到的字符串都满足代码块的缓存机制：

​	2,乘法得到的字符串分两种情况：

　　	2.1 乘数为1时，任何字符串满足代码块的缓存机制：

​		2.2 乘数>=2时：仅含大小写字母，数字，下划线，总长度<=20，满足代码块的缓存机制：

**优点**：能够提高一些字符串，整数处理在时间和空间上的性能；

​	  需要值相同的字符串，整数的时候，直接从‘字典’中取出复用，避免频繁的创建和销毁，提升效率，节约内存。

**小数据池:**小数据池，不同代码块的缓存机制，也称为小整数缓存机制

Python自动将-5~256的整数进行了**缓存**，当你将这些整数赋值给变量时，并不会重新创建对象，而是使用已经创建好的缓存对象。

python会将一定规则的字符串在**字符串驻留池**中，创建一份，当你将这些字符串赋值给变量时，并不会重新创建对象， 而是使用在字符串驻留池中创建好的对象。

　　其实，无论是缓存还是字符串驻留池，**都是python做的一个优化，就是将~5-256的整数，和一定规则的字符串，放在一个‘池’（容器，或者字典）中，无论程序中哪些变量指向这些范围内的整数或者字符串，那么他直接在这个‘池’中引用，言外之意，就是内存中之创建一个。**

### **3、a = [], b=[], a is b 返回什么**

```python
a,b=[],[]
print(a is b)#False
print(a is None)#False
print(not a)#True

在python中 None,  False, 空字符串"", 0, 空列表[], 空字典{}, 空元组()都相当于False 
```

### 4、你判断是否是None时候用的is还是==?为什么用is可以判断?

**因为None在Python里是个单例对象，一个变量如果是None，它一定和None指向同一个内存地址。**

**None:**

​	1、**None有自己的数据类型NontType，你可以将None赋值给任意对象，但是不能创建一个NoneType对象。**

​	2、None是python中的一个特殊的常量，表示一个空的对象，空值是python中的一个特殊值。数据为空并不代表是空对象，例如[],’'等都不是None。**None和任何对象比较返回值都是False，除了自己。**

​	如果`not x` 你是想判断x是否为None，但是这样写会把x==[]的情况也包含进来了，这么无法区分两种情况。下面的`not x is None`是正确的，却不是很好理解，其意思是`not (x is None)`, 最好的写法是 `if x is not None`，即清晰又不会出现问题。

### Python中else的用法总结

- Python中的for、while是在循环体内没有break语句、没有return语句，或者没有异常出现时才执行else语句，try..except…else是在try中无异常产生时执行，注意不包括continue。
- 总的来说，是for、while、try语句中‘没毛病’时才执行，而在if..else语句中是if语句判断为假（有毛病）才执行else，这一点要区分开来

### 5、**python闭包**

闭包： 

　　**在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。**

一般情况下，在我们认知当中，如果一个函数结束，函数的内部所有东西都会释放掉，还给内存，局部变量都会消失。**但是闭包是一种特殊情况，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。**

**#内函数中想修改闭包变量：nonlocal关键字声明**

```python
#修改闭包变量的实例
# outer是外部函数 a和b都是外函数的临时变量
def outer( a ):
    b = 10  # a和b都是闭包变量
    c = [a] #这里对应修改闭包变量的方法2
    # inner是内函数
    def inner():
        #内函数中想修改闭包变量
        # 方法1 nonlocal关键字声明
        nonlocal  b
        b+=1
        # 方法二，把闭包变量修改成可变数据类型 比如列表
        c[0] += 1
        print(c[0])
        print(b)
    # 外函数的返回值是内函数的引用
    return inner

if __name__ == '__main__':

    demo = outer(5)
    demo() # 6  11
```

**还有一点需要注意：使用闭包的过程中，一旦外函数被调用一次返回了内函数的引用，虽然每次调用内函数，是开启一个函数执行过后消亡，但是闭包变量实际上只有一份，每次开启内函数都在使用同一份闭包变量**

```python
#coding:utf8
def outer(x):
    def inner(y):
        nonlocal x
        x+=y
        return x
    return inner


a = outer(10)
print(a(1)) //11
print(a(3)) //14
```



**闭包作用：**

 3.1装饰器！！！装饰器是做什么的？？其中一个应用就是，我们工作中写了一个登录功能，我们想统计这个功能执行花了多长时间，我们可以用装饰器装饰这个登录模块，装饰器帮我们完成登录函数执行之前和之后取时间。

 3.2面向对象！！！经历了上面的分析，我们发现外函数的临时变量送给了内函数。大家回想一下类对象的情况，对象有好多类似的属性和方法，所以我们创建类，用类创建出来的对象都具有相同的属性方法。闭包也是实现面向对象的方法之一。在python当中虽然我们不这样用，在其他编程语言入比如avaScript中，经常用闭包来实现面向对象编程

3.3实现单利模式！！ 其实这也是装饰器的应用。单利模式毕竟比较高大，，需要有一定项目经验才能理解单利模式到底是干啥用的，我们就不探讨了。

### 6、[URL的结构介绍](https://www.cnblogs.com/be-saber/p/4734951.html)

| **Scheme:** | **//** | **Login:password@**               | **Address**    | **:port** | **/path/to/resource** | **?query_string** | **#fragment** |
| ----------- | :----- | --------------------------------- | -------------- | --------- | --------------------- | ----------------- | ------------- |
| 协议：      |        | **Login:password@部分：身份验证** | **服务器地址** | 端口      | **文件路径**          | **查询字符串**    | **片段ID**    |

**//部分：层级URL标识符号**

​      基本上每个URL中都会包含这个符号，是固定的；可以理解为把协议与后面的信息进行分隔开的一个符号。按照书上的说明，一个好处是Web应用无需关注某个协议的具体实现，而只需要关注于’//’符号后面的指向地址即可。

**#fragment: 片段ID**

​      该部分与上面的?后面的表单信息本质的区别就是这部分内容不会被传递到服务器端。一般用于页面的锚。就是我们常见的网站右下脚一般有一个回到顶部的按钮，一般就是使用其实现的。

proto://user:password@domain:port/path?key=value&key=value

### 7、OSI五层协议，你从应用层开始说一下你知道的协议, 和他用干嘛的？

五层体系结构包括：应用层、运输层、网络层、数据链路层和物理层。

![img](https://img-blog.csdnimg.cn/20190527192517601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmppbmlhbzE=,size_16,color_FFFFFF,t_70)

1. **第五层——应用层(application layer)** 报文
   应用层(application layer)：是体系结构中的最高层。直接为用户的应用进程提供服务（例如电子邮件、文件传输和终端仿真）。
   在因特网中的应用层协议很多**，如支持万维网应用的HTTP协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议，DNS，**POP3，SNMP，Telnet等等。
2. **第四层——运输层(transport layer)** 报文段/用户数据报
   运输层(transport layer)：负责向两个主机中**进程之间**的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能。
   **复用**：就是多个应用层进程可同时使用下面运输层的服务。
   **分用**：就是把收到的信息分别交付给上面应用层中相应的进程。
   运输层主要使用以下两种协议：
   (1) 传输控制协议TCP(Transmission Control Protocol)：面向连接的，数据传输的单位是报文段，能够提供可靠的交付。
   (2) 用户数据包协议UDP(User Datagram Protocol)：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。
3. **第三层——网络层(network layer)**数据报
   网络层(network layer)主要包括以下 两个任务：
   (1) 负责为分组交换网上的不同主机提供通信服务。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做**IP数据报**，或简称为**数据报**。
   (2) 选中合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器**找到目的主机**。
   **协议**：IP,ICMP,IGMP,ARP,RARP
4. **第二层——数据链路层(data link layer)** 帧
   1.**数据链路层(data link layer)**：常简称为链路层，我们知道，两个主机之间的数据传输，总是在一段一段的链路上传送的，也就是说，在两个相邻结点之间传送数据是直接传送的(点对点)，这时就需要使用专门的链路层的协议。
   2.**在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧(framing)，在两个相邻结点之间的链路上“透明”地传送帧中的数据。**
   3.每一帧包括数据和必要的控制信息(如同步信息、地址信息、差错控制等)。典型的帧长是几百字节到一千多字节。
5. **第一层——物理层(physical layer)** 比特
   物理层(physical layer)：在物理层上所传数据的单位是**比特**。物理层的任务就是**透明地传送比特流**。

**ICMP协议**：ICMP协议是一种面向无连接的协议，用于传输出错报告控制信息。它是一个非常重要的协议，它对于[网络安全](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8)具有极其重要的意义。 它属于[网络层协议](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE)，主要用于在主机与路由器之间传递控制信息，包括报告错误、交换受限控制和状态信息等。当遇到IP数据无法访问目标、IP[路由器](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E5%99%A8)无法按当前的传输速率转发[数据包](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8C%85)等情况时，会自动发送ICMP消息。

ICMP 是 TCP/IP 模型中网络层的重要成员，与 IP 协议、ARP 协议、RARP 协议及 IGMP 协议共同构成 TCP/IP 模型中的网络层。ping 和 tracert是两个常用网络管理命令，**ping 用来测试网络可达性，tracert 用来显示到达目的主机的路径。**ping和 tracert 都利用 ICMP 协议来实现网络功能，它们是把网络协议应用到日常网络管理的典型实例。

**IGMP(Internet Group Management Protocol)**互联网组管理协议是TCP/IP 协议族中负责IP组播成员管理的协议，用来在IP主机和与其直接相邻的组播路由器之间建立、维护组播组成员关系。

**PPP协议：**点到点协议（Point to Point Protocol，PPP）是为在同等[单元](https://baike.baidu.com/item/%E5%8D%95%E5%85%83/32922)之间传输[数据包](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8C%85)这样的简单链路设计的[链路层](https://baike.baidu.com/item/%E9%93%BE%E8%B7%AF%E5%B1%82)协议。 这种链路提供全双工操作，并按照顺序传递数据包。设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和[路由器](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E5%99%A8)之间简单连接的一种共通的解决方案。PPP具有以下功能：

（1）PPP具有动态分配[IP](https://baike.baidu.com/item/IP)地址的能力，允许在连接时刻协商IP地址；

（2）PPP支持多种[网络协议](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE)，比如[TCP/IP](https://baike.baidu.com/item/TCP%2FIP)、[NetBEUI](https://baike.baidu.com/item/NetBEUI)、[NWLINK](https://baike.baidu.com/item/NWLINK)等；

（3）PPP具有错误检测能力，但不具备纠错能力，所以ppp是不可靠传输协议；

（4）无重传的机制，网络开销小，速度快。

（5）PPP具有[身份验证](https://baike.baidu.com/item/%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81)功能。

（6） PPP可以用于多种类型的物理介质上，包括串口线、电话线、移动电话和光纤（例如SDH），PPP也用于Internet接入。

###　８、那tcp为什么非得三次握手, 不可以两次?　那三次握手客户端会发送什么包?　那四次挥手为什么必须四次?　那第二次挥手和第三次挥手可以合并吗?



###  9、**既然mac地址是唯一的, 那为什么不直接用mac地址做链接,还要用IP地址？**

为什么不直接使用MAC地址进行通信

1、全世界存在各种各样的异构网络，它们使用不同的硬件地址(网络的异构性体现），要使这些异构网络能够进行通信，就需要非常复杂的硬件地址转换工作，因此由用户主机来完成这件事几乎是不可能的，**使用统一的IP地址，就使得所有的主机都在同一个IP网络内进行通信。**

2、MAC地址就像身份证一样，它只唯一的标志一个网络接口，**它没有被设计为具有寻址功能。**



为什么不直接使用IP地址通信

1、**因为并非每个主机都一个公网IP,很多主机都是使用的内网IP，依据NAT对外访问**

2、**应用DHCP(动态主机配置协议），IP地址是动态变化的**，比如说这个主机刚刚是这个IP，忽然断网了，被分配给另一个IP了，那么数据就会被传输给另外一个主机了。

### 10、Flask架构？和Django的区别？

django走的是大而全的路线，是重量型的框架，flask是一轻量级的框架

django事模块式的开发方式，1，有完善的ORM模型，评价略高于sqlAlchemy，和模板引擎（强大程度略低于jinja）2，非常适合企业级的开发（高效，稳定，）3，开发文档比较完善。

flask走的是灵活多变的路线，1，有各种第三方的插件支持，可拓展性强。2，flask与关系型数据库的配合不弱于django，但与Nosql非关系型数据库的配合由于django。3，适应小网站

**Django框架流程**

- 1、浏览器发送请求request给web服务器；

- 2、web服务器将请求转发给Django框架处理；
  （Django接收到第一个请求，会调用中间件的`__init__`方法，完成中间件的初始化）

- 3、处理请求前调用proces_request(request)，返回None或HttpResponse对象；

- 4、通过URLconf匹配，确认请求由哪个视图处理；

- 5、process_view(request,view_func,view_args,view_kwargs)在处理视图前调用,返回None或HttpResponse对象；

- 6、视图接收到resquest;

  (1) 通过模型model与数据库交互，获取并处理数据，Model内嵌ORM框架，实现面向对象来操作数据库；
  (2) 模板引擎，实现动态展示数据，返回HttpResponse对象或者JsonResponse对象。

- 7、视图处理响应后返回response，所有的response（包括process_request和process_view返回的response）在返回给Django前都会调用process_response(request,response)，返回HttpResponse对象，除非做了特殊处理。

  （如果视图抛出异常，在每个请求上调用precess_exception(request,exception),返回None或HttpResponse对象。）

**ORM（对象关系映射）的优缺点**

  首先，ORM最大的**优势**。隐藏了数据访问细节，“封闭”的通用数据库交互，ORM的核心。他使得我们的通用数据库交互变得简单易行，并且完全不用考虑该死的SQL语句。快速开发，由此而来。第二：ORM使我们构造固化数据结构变得简单易行。  

**缺点：**
第一：无可避免的，自动化意味着映射和关联管理，代价是牺牲性能（早期，这是所有不喜欢ORM人的共同点）。现在的各种ORM框架都在尝试使用各种方法来减轻这块（LazyLoad，Cache），效果还是很显著的。
第二：面向对象的查询语言(X-QL)作为一种数据库与对象之间的过渡,虽然隐藏了数据层面的业务抽象,但并不能完全的屏蔽掉数据库层的设计,并且无疑将增加学习成本.
第三： 对于复杂查询，ORM仍然力不从心。虽然可以实现，但是不值的

### 11、**了解python里的锁吗, 说下GIL**

### 12、索引为什么快？B树和B+树？MySQL有做过优化么？知道或者用过mysql里的锁没有？

行锁、表锁、页锁、共享锁、排他锁、间隙锁、乐观锁（version，多读）、悲观锁（多写）

### 13、死锁

死锁产生的4个必要条件？

产生死锁的必要条件：

1. 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
2. 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
4. 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

解决死锁的基本方法

预防死锁：

- 资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
- 只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
- 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
- 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

### 14、你知道python多线程什么情况下比较适用

**计算密集型**    

计算密集型，顾名思义就是应用需要非常多的CPU计算资源，在计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。

**IO密集型**

对于IO密集型的应用，涉及到网络、磁盘IO的任务都是IO密集型任务，大多消耗都是硬盘读写和网络传输的消耗。 

那么GIL多线程的不足，其实是对于计算密集型的不足，这个解决可以利用多进程进行解决，而对于IO密集型的任务，我们还是可以使用多多线程进行提升效率。

### 15、多进程通信

管道、命名管道、消息队列、共享内存、socket通信

```python
from multiprocessing import Process, Pipe

def pstart(pname, conn):
    conn.send("Data@subprocess")
    print(conn.recv())          # Data@parentprocess

if __name__ == '__main__':
    conn1, conn2 = Pipe(True)
    sub_proc = Process(target=pstart, args=('subprocess', conn2,))
    sub_proc.start()
    print (conn1.recv())        # Data@subprocess
    conn1.send("Data@parentprocess")
    sub_proc.join()
    
管道通信三步曲：
创建Pipe，得到两个connection对象conn1和conn2；
父进程持有conn1，将conn2传递给子进程；
父子进程通过对持有的connection对象进行send和recv操作以进行数据传递和接受；
```

消息队列

```python
from multiprocessing import Process, Queue
import time

def producer(que):
    for product in ('Orange', 'Apple', ''):
        print('put product: %s to queue' % product)
        que.put(product)
        time.sleep(0.5)
        res = que.get()
        print('consumer result: %s' % res)

def consumer(que):
    while True:
        product = que.get()
        print('get product:%s from queue' % product)
        que.put('suc!')
        time.sleep(0.5)
        if not product:
            break

if __name__ == '__main__':
    que = Queue(1)
    p = Process(target=producer, args=(que,))
    c = Process(target=consumer, args=(que,))
    p.start()
    c.start()
    p.join()
    c.join()
```

### 16、多线程通信

1.threading.Lock()

 如果多个线程对某一资源同时进行修改，可能会存在不可预知的情况。为了修改数据的正确性，需要把这个资源锁住，只允许线程依次排队进去获取这个资源。当线程A操作完后，释放锁，线程B才能进入。如下脚本是开启多个线程修改变量的值，但输出结果每次都不一样。

2.threading.Rlock()

 用法和 threading Lock() 一致，区别是 threading.Rlock() 允许多次锁资源，acquire() 和 release() 必须成对出现，也就是说加了几把锁就得释放几把锁。

3.threading.Condition()

4.threading.Event()

### 17、yield

**yield和return的关系和区别了，带yield的函数是一个生成器，而不是一个函数了，这个生成器有一个函数就是next函数，next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从foo函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。**

1. 我理解的生成器(generator)能够迭代的关键是它有一个next()方法，工作原理就是通过重复调用next()方法，直到捕获一个异常。可以用上面的mygenerator测试。
2. 带有 yield 的函数不再是一个普通函数，而是一个生成器generator，可用于迭代，工作原理同上。
3. yield 是一个类似 return 的关键字，迭代一次遇到yield时就返回yield后面的值。重点是：下一次迭代时，从上一次迭代遇到的yield后面的代码开始执行。
4. 简要理解：yield就是 return 返回一个值，并且记住这个返回的位置，下次迭代就从这个位置后开始。

### 18、Linux查询端口被占用命令

**1、lsof -i:端口号**

-----用于查看某一端口的占用情况，比如查看8000端口使用情况，lsof -i:8000

**2、netstat -tunlp |grep 端口号**

-----用于查看指定的端口号的进程情况，如查看8000端口的情况，netstat -tunlp |grep 8000

**常用命令：**

```
netstat -ntlp   //查看当前所有tcp端口
netstat -ntulp | grep 80   //查看所有80端口使用情况
netstat -ntulp | grep 3306   //查看所有3306端口使用情况
```

 **参数介绍：**

**-t (tcp) 仅显示tcp相关选项**
**-u (udp)仅显示udp相关选项**
**-n 拒绝显示别名，能显示数字的全部转化为数字**
**-l 仅列出在Listen(监听)的服务状态**
**-p 显示建立相关链接的程序名**

**3、ps -aux | grep tonmcat**

**查看进程：**

```
1. ps -ef|grep 进程名       ps -ef 是显示所有进程
```

### 19、Linux软、硬链接

[【Linux】Linux系统硬链接和软链接](https://www.cnblogs.com/songgj/p/9115954.html)

链接的方式可以分为两种，一种是硬链接（Hard Link），另一种是软链接或者也称为符号链接（Symbolic Link）。

软连接和硬链接的特点：（ln）

软链接：

- 1.软链接是存放另一个文件的路径的形式存在。
- 2.软链接可以 跨文件系统 ，硬链接不可以。
- 3.软链接可以对一个不存在的文件名进行链接，硬链接必须要有源文件。
- 4.软链接可以对目录进行链接。

硬链接：

- \1. 硬链接，以文件副本的形式存在。但不占用实际空间。
- \2. 不允许给目录创建硬链接。
- \3. 硬链接只有在同一个文件系统中才能创建。
- \4. 删除其中一个硬链接文件并不影响其他有相同 inode 号的文件。

**不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。**