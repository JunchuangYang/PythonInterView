# 深信服实习一面(凉经)

**33min**

**记录一下，人生第一次正儿八经接受技术面**（本科毕业后的在郑州的面试都是小打小闹）。

总的来说不难，都是Python基础题，**但是**，基础题深问我也不是太会啊。

面试官还行，一看就是搞技术的，比较年轻，在家面试。

总体来说分了两个方向：**Python和数据结构。**

**Python：**

​	以下不分先后顺序，想到哪写哪：

​			1.Python常用的数据结构有哪些，以及它们的应用？

​			2.数组和链表的区别，以及它们的应用场景？

​			3.字典的底层实现，字典的取值方式？[]和get的区别？

​			4.进程，线程，协程的区别？协程为什么比进程快？协程是怎样开始和取消的？

​			5.yield的使用方式？yield和协程的区别和联系？

​			6.Python捕获异常的方式？try...except...finally?except 中包含return或raise时finally会不会执行？抛出异常的方式？

​			7.装饰器的原理及应用？

​			8.python的垃圾回收机制介绍一下？

**数据结构：**

​	1.hash算法介绍？处理冲突？解决冲突后我怎么知道我要获取的值是我想要的？(Python字典底层解决冲突的方法)

​	2.大顶堆介绍？特性？如何插入？

​	3.给你一篇英文文章，找出次数最多的前十个单词？



最后反问的时候我问了第三个问题，需要怎么解决，我回答的是一般人都能想到的方法，感觉回答的不太好所以想知道这个答案？

面试官说：先用hash算法对单词进行hash，hash值与单词一一对应（其实就是字典的key:value），对hash后的值使用大顶堆排序。

说完后我就没在问了。

现在想想其实我该在反问一句，hash后的单词我怎么判断是冲突的词还是重复的词，我怎么对单词的个数进行+1操作。（最近看了一下Python dict 的原理，明白了这个原理。hash后首先判断key值是否相等，相等则直接取出，不相等则冲突；冲突后在使用，算法会在散列值中另外再取几位重新进行判断）

----

**还是要多面试才能发现自己的问题。**



----

## 更新：正式批一面（感觉又没了）

<https://www.cnblogs.com/ericli-ericli/p/12873061.html>

1.手写快排(又卡壳，太菜了)

2.手写装饰器

3.数组和链表的区别及应用场景？

4.快排和堆排的应用场景?

- (1)若n较小(如n≤50)，可采用直接插入或直接选择排序。

  ​	当记录规模较小时，直接插入排序较好；否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。

- (2)若文件初始状态基本有序(指正序)，则应选用直接插人、冒泡或随机的快速排序为宜；

- (3)若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。

   -  快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短;

       - 堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。这两种排序都是不稳定的;

       - 若要求排序稳定，则可选用归并排序。
       - 优先队列通常用堆排序来实现

5.大根堆和小根堆？

6.用数组模拟静态链表？

​	<https://www.cnblogs.com/dongry/p/10210609.html>

7.红黑树与平衡二叉树的区别？平衡二叉树查找时间复杂度？

​	[红黑树与平衡二叉树](https://www.cnblogs.com/ericli-ericli/p/12873061.html)

​	**红黑树的性质**

​	性质1.节点是红色或黑色。

​	性质2.根节点是黑色。

​	性质3.每个叶子节点都是黑色的空节点（NIL节点）。

​	性质4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

​	性质5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

​	这些约束强制了红黑树的关键性质: **从根到叶子的最长的可能路径不多于最短的可能路径的两倍长**。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。

​	平衡二叉树(AVL)的性质:它是一 棵**空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树**。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。

区别： 

- 红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。

- 平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。

8.进程和线程和协程的区别？

9.hash冲突的解决办法？不利于使用hash算法的场景？

​	**总结一下的就是下面的四行字：**

​	1.开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）
​	2.再哈希法
​	3.链地址法(Java hashmap就是这么做的)
​	4.建立一个公共溢出区

​	**哈希算法应用场景**  :**安全加密**，**唯一标识，数据校验**

10.python的垃圾回收机制？

11.Django的Session机制？

​	[Django的session机制](<https://blog.csdn.net/zzy_zatan/article/details/99695205>)

12.一致性哈希？

​	[一致性Hash原理与实现](<https://www.jianshu.com/p/528ce5cd7e8f>)

​	一致性的Hash算法是对`2的32方`取模。即，一致性Hash算法将整个Hash空间组织成一个虚拟的圆环，Hash函数的值空间为`0 ~ 2^32 - 1(一个32位无符号整型)`.